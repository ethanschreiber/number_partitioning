/*
 * Schroeppel_Shamir.hpp
 *
 *  Created on: Oct 3, 2012
 *      Author: ethan
 */

#ifndef SCHROEPPEL_SHAMIR_HPP_
#define SCHROEPPEL_SHAMIR_HPP_

#include "SubsetSum.hpp"
#include "../Heap.hpp"
#include <vector>
#include <deque>
#include <algorithm>

using std::vector;
using std::deque;

namespace ss {

// ============================================================
// The Node to be stored in the Schroeppel and Shmir Heap class
// ============================================================
struct SSHeapNode {   // heap of sums from a and b in increasing order
  size_t x;           // index of element in asums
  size_t y;           // index of element in bsums
  uint64_t sum;        // sum of the elements

  SSHeapNode(size_t x0, size_t y0,uint64_t sum0) : x(x0), y(y0), sum(sum0) {}

  SSHeapNode(size_t x0, size_t y0,const ss::SSSetNode &setNode) : x(x0), y(y0), sum(setNode.sum()) {}

  SSHeapNode(size_t x0, size_t y0,const vector<uint64_t> &xVector,const vector<uint64_t> &yVector)
  : x(x0), y(y0), sum(xVector[x0] + yVector[y0]) { }

  SSHeapNode(size_t x0, size_t y0,const vector<ss::SSSetNode> &xVector,const vector<ss::SSSetNode> &yVector)
  : x(x0), y(y0), sum(xVector[x0].sum() + yVector[y0].sum()) { }

  SSHeapNode() {}
};

// ======================================================
// Min and Max heap Comparators for Schroeppel and Shamir
// ======================================================
struct SSMinHeapComparator {

public :
  bool operator()(const SSHeapNode &a, const SSHeapNode &b) {
    return a.sum > b.sum;
  }
};

struct SSMaxHeapComparator {

public :
  bool operator()(const SSHeapNode &a, const SSHeapNode &b) {
    return a.sum < b.sum;
  }
};

// ============================================
// Typedef MinHeap and MaxHeap to use the heaps
// ============================================
typedef Heap<SSMinHeapComparator,SSHeapNode> SSMinHeap;
typedef Heap<SSMaxHeapComparator,SSHeapNode> SSMaxHeap;


// ============================================================================
// Schroeppel and Shamir Helper Functions
// ============================================================================

void initializeSets(const uint64_t S[MAXN], const int n,
                           vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d);

void initializeHeaps(const uint64_t S[MAXN], const int n,
                       vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d,
                       SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper);

void initialize(const uint64_t S[MAXN], const int n,
                       vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d,
                       SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper);


// **************************
// * THE EXTERNAL FUNCTIONS *
// **************************

// allSets has a vector of ints
size_t generateSetsSS(const uint64_t S[MAXN], const int n, const uint64_t lower, const uint64_t upper,
                      vector<SetNode> &allSets);


// Given a set of n input numbers S, a lower and upper bound,
// this generates all sets within lower and upper and puts them in allSets.
// This is a template function, ContainerT must have member functions
// push_back(SSSetNode) and and size().
// Furthermore, the type of the data being stored by the template must be
// SSSetNode. i.e. std::vector<SSSetNode> would be a valid type to pass for allSets

template <typename ContainerT>
size_t generateSetsSS(const uint64_t S[MAXN], const int n,
                      const uint64_t lower, const uint64_t upper,
                      ContainerT &allSets)

{
  vector<SSSetNode> a;          // all subset sums from first quarter of numbers
  vector<SSSetNode> b;          // all subset sums from second quarter of numbers
  vector<SSSetNode> c;          // all subset sums from third quarter of numbers
  vector<SSSetNode> d;          // all subset sums from fourth quarter of numbers

  SSMinHeap abheap;    // Min Heap Comparator
  SSMaxHeap cdheap;   // Max Heap Comparator

  deque<SSHeapNode> cdlist;    // list of subset sums removed from CD heap

  // Initialize the 4 vectors and 2 heaps
  initialize(S,n,a,b,c,d,abheap,cdheap,upper);
  // --------------------------------------------------------------------------
  // Now fill in the allsums vector
  // --------------------------------------------------------------------------

  while (!abheap.empty()) {                      // until AB heap is empty

    // remove sets with sums above upper bound from cdlist
    while (!cdlist.empty() && abheap.front().sum + cdlist.front().sum > upper) {
      cdlist.pop_front();
    }

    // add new sets with sums within bounds to cdlist
    uint64_t topsum = cdheap.front().sum + abheap.front().sum;     //sum of elements on top of heaps
    while (!cdheap.empty() && topsum >= lower) {         // new set within bounds

      if (topsum <= upper) {                             // new set within bounds
        cdlist.push_back(cdheap.front());                // add heap element to list
      }

      if (cdheap.front().y > 0) {                        // there is another element in this column
        SSHeapNode newElement(cdheap.front().x,          // keep same row
                              cdheap.front().y - 1,      // replace with next combination in column
                              c,d);                      // sum is c[x] + d[y-1]

        cdheap.pop();                                    // Remove old head
        cdheap.push(newElement);                         // add new element to heap vector

      } else {                                           // no more elements in this column
        cdheap.pop();                                    // Remove old head
      }

      topsum = cdheap.front().sum + abheap.front().sum;      // sum of two top elements of heaps
    }

    // Combine each element from cdlist with the top element from
    // abheap, these are all within range
    for (size_t index=0;index<cdlist.size();index++) {
      uint64_t subsum = cdlist[index].sum + abheap.front().sum;  // first subset sum
      allSets.push_back(SSSetNode(subsum, c[cdlist[index].x].set() |
                                       d[cdlist[index].y].set() |
                                       a[abheap.front().x].set() |
                                       b[abheap.front().y].set()));
    }

    // If there is another element from the b set, add it.
    // Then, remove top element from abheap.
    if (abheap.front().y < b.size() - 1) {          // there is another element in this column
      SSHeapNode newNode(abheap.front().x,            // new element being added to heap
                       abheap.front().y + 1,        // replace with next combination in this column
                       a,b);

      abheap.pop();                            // Pop old value
      abheap.push(newNode);                    // add new element to heap vector
    } else {
      abheap.pop();
    }
  }

  return allSets.size();                                 // return the number of subset sums stored in ALLSUMS
}

} // end namespace

#endif /* SCHROEPPEL_SHAMIR_HPP_ */
