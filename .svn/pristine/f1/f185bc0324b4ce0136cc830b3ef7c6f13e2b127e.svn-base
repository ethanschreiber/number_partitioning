/*
 * BinPackingUtils.cpp
 *
 *  Created on: Aug 2, 2012
 *      Author: ethan
 */

#include "PackingUtils.hpp"
#include "globals.hpp"
#include <sys/stat.h>
#include <dirent.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <numeric>  // for std::accumulate
#include <iomanip>
#include <algorithm>
using std::cout;
using std::endl;

// ***************
// Solution Method
// ***************
SolutionMethod getSolutionMethod(int solutionMethodIdx) {

  switch (solutionMethodIdx) {
  case 0 : return BIN_COMPLETION;
  case 1 : return RECURSIVE_NUMBER_PARTITIONING;
  case 2 : return BELOV_BCP;
  case 3 : return MOFFITT;
  case 4 : return MOFFITT_RICH;
  case 5 : return MOFFITT_CACHED;
  default :
    cout << "ERROR: Must enter 0 for bin completion, 1 for recursive number partitioning, 2 for Belov branch-and-cut-and-price or 3 for Moffitt." << endl;
    exit(0);
  }
  return BIN_COMPLETION;    // This should never happen!
}

// *******************
// PackingProblem
// *******************
PackingProblem::PackingProblem(int N0, uint64_t S0[], uint64_t sum0, string problemName0 )
: N(N0), sum(sum0), problemName(problemName0) {
  S = new uint64_t[N];
  memcpy(S,S0,sizeof(uint64_t) * N);
}

PackingProblem::~PackingProblem() {
  delete [] S;
}
PackingProblem::PackingProblem(const string &filename) {
  load(filename);
}


PackingProblem::PackingProblem(const PackingProblem &problem)
: N(problem.N), sum(problem.sum), problemName(problem.problemName) {

  S           = new uint64_t[N];
  memcpy(S,problem.S,N * sizeof(uint64_t));
}

void PackingProblem::readElements(std::ifstream &inFile) {

  S = new uint64_t[N];     // Allocate memory for S
  for (int i=0;i<N;i++) { // Fill in S values
    if (!inFile) {
      cout << "Not enough entries, expected " << N << ", got " << i << endl;
      exit(0);
    }
    inFile >> S[i];
  }

  uint64_t next;     // Make sure no more
  inFile >> next;

  if (inFile) {
    cout << "Entries left over, perhaps you should have used a different PackingProblem struct?" << endl;
    cout << "Next: " << next << endl;
    cout << "Sum : " << sum << endl;
    for (int i=0;i<N;i++) {
      cout << "--> " << S[i] << endl;
    }
    exit(0);
  }

  sum = std::accumulate(S,S + N,(uint64_t) 0);   // sum is sum of all elements in S

}

void PackingProblem::load(string filename) {
  std::ifstream inFile(filename);
  std::getline(inFile,problemName);   // Read problem Name

  inFile >> N >> sum;                       // [N] [sum]
  readElements(inFile);
  inFile.close();
}

// *******************
// PartitioningProblem
// *******************
PartitioningProblem::PartitioningProblem(int N0, int K0, uint64_t S0[], uint64_t sum0, string problemName0 )
  : PackingProblem(N0,S0,sum0,problemName0), K(K0) {}


PartitioningProblem::PartitioningProblem(const string &filename) {
  load(filename);
}

PartitioningProblem::PartitioningProblem(const PartitioningProblem &problem)
: PackingProblem(problem), K(problem.K) {}

PartitioningProblem::PartitioningProblem(const PackingProblem &problem, int K0)
: PackingProblem(problem), K(K0) {}

void PartitioningProblem::load(const string &filename) {
  std::ifstream inFile(filename);
  std::getline(inFile,problemName);   // Read problem Name

  inFile >> K >> N >> sum;            // [k] [N] [sum]
  readElements(inFile);

}

// *****************
// BinPackingProblem
// *****************
BinPackingProblem::BinPackingProblem(const string &filename, int lowerBound) {

  //cout << "Reading " << filename << endl;

  std::ifstream inFile(filename);
  std::getline(inFile,problemName);

  inFile >> capacity >> N >> sum;
  readElements(inFile);
}

BinPackingProblem::BinPackingProblem(const PackingProblem &packingProblem, uint64_t capacity, int lowerBound)
: PackingProblem(packingProblem), capacity(capacity), lowerBound(lowerBound)
{}

BinPackingProblem::BinPackingProblem(const uint64_t capacity, int lowerBound) : capacity(capacity), lowerBound(lowerBound) {
  S = NULL;
  N = 0;
  sum = 0;
}

void BinPackingProblem::reset(uint64_t S0[MAXN],size_t N0) {
  if (S != NULL) {
    delete [] S;
  }
  sum = 0;
  N = N0;
  S = new uint64_t[N];

  for (int i=0;i<N;i++) {
    S[i] = S0[i];
    sum += S[i];
  }
}
string BinPackingProblem::toString() const {
  std::ostringstream out;
  out << "Problem Name: " << problemName << endl
      << "Bin Capacity: " << capacity<< endl
      << "# Items     : " << N << endl
      << "Sum         : " << sum << endl;
  return out.str();
}

// *****************************
// Bin Packing Utility Functions
// *****************************

// Upper Bound
uint64_t BFD(uint64_t items[MAXN],int solution[MAXN],int numItems,uint64_t capacity) {                                /* array of numbers */

  int numBins = 0;  // number of bins used
  int binum[MAXN];  // the original # of the bin in each current position
  uint64_t binSum[MAXN]; // the sums in the bins so far

  for (int i = 0; i < numItems; i++) {      // for each bin
    binum[i] = i;                           // its original index
    binSum[i] = 0;                          // initialize bins to empty
  }

  for (int i = 0; i < numItems; i++) {          // for each number
    int j = 0;                                  // start with first bin
    while (items[i] + binSum[j] > capacity) {
      j++;                                      // try next if it doesn't fit
    }
    uint64_t newbinsum = binSum[j] + items[i];       // insert into first bin it fits, or last bin
    solution[i] = binum[j];                     // store assignments in solution vector
    if (j >= numBins) {
      numBins++;                                // keep track of how many bins used
    }

    while (j > 0 && binSum[j-1] < newbinsum) {  // resort bins from fullest to emptyest
      binSum[j] = binSum[j-1];                  // element is less full than newbin
      binum[j] = binum[j-1];                    // keep track of original indices
      j--;                                      // see if greater than next bin as well
    }
    binSum[j] = newbinsum;                      // insert new bin in sorted order
    binum[j] = solution[i];                     // keep track of original index of bin
  }

  return (numBins);
}

uint64_t BFD(uint64_t items[MAXN],int numItems,uint64_t capacity) {
  int * solution = new int[numItems];
  uint64_t result = BFD(items,solution,numItems,capacity);
  delete [] solution;

  return result;
}


// Lower bound
uint64_t L2(uint64_t S[MAXN],         // The elements to be assigned
       int N,               // The number of elements
       uint64_t capacity,        // The capacity of a bin
       uint64_t sum) {           // Sum of all of the elements.

  int first     = 0;        // the index of the largest element
  int last      = N-1;      // the index of the smallest element
  uint64_t waste     = 0;        // the amount of wasted space computed so far
  uint64_t carryover = 0;        // the sum of the elements that haven't been used so far

  while (first <= last) {                     // while there are still elements remaining
    uint64_t empty = capacity - S[first];              // empty space in bin with largest element
    while (last > first && S[last] <= empty){ // elements left that fit
      carryover += S[last];                   // add to total that could fit in this bin
      last--;                                 // try next larger element
    }

    if (carryover < empty) {                  // all that can fit does
      waste += empty - carryover;             // rest is wasted space
      carryover = 0;                          // all carryover is consumed by this bin
    } else {
      carryover -= empty;                     // reduce carryover by as much as fits in bin
    }
    first++;                                  // try next largest element
  }

  uint64_t total = sum + waste;                    // total capacity needed
  uint64_t numBins = total / capacity;             // number of bins needed for this total
  if(numBins * capacity < total) numBins++;   // didn't divide evenly, round up

  return numBins;                             // return lower bound on bins needed
}

// ************************
// String utility functions
// ************************

string getDirOfFile(string filename) {
  string fullpath(filename);
  size_t last = fullpath.find_last_of('/');
  return fullpath.substr(0,last+1);
}

string getFilename(string fullFilename) {
  string fullpath(fullFilename);
  size_t last = fullpath.find_last_of('/');
  return fullpath.substr(last+1,fullpath.size());
}
string getLastDir(string fullFilename) {
  string dir = getDirOfFile(fullFilename);
  dir = dir.substr(0,dir.size()-1);
  return getFilename(dir);
}

string addTrailingSlash(string dirname) {
  if (dirname[(dirname.size() - 1)] != '/') {
    dirname.append("/");
  }
  return dirname;
}

string removeTrailingSlash(string dirname) {
  if (dirname[(dirname.size() - 1)] == '/') {
    dirname.resize(dirname.size()-1);
  }
  return dirname;
}



bool startsWith(string s,string prefix) {

  // Note: strtncmp returns 0 if the first prefix.size() elements
  // are the same, hence the !

  return ((s.size() >= prefix.size()) &&
          (!strncmp(s.c_str(),prefix.c_str(),prefix.size())));
}

bool endsWith(string s,string suffix) {

  // Note: strtncmp returns 0 if the first prefix.size() elements
  // are the same, hence the !

  return ((s.size() >= suffix.size()) &&
          (0 == s.compare(s.length() - suffix.length(), suffix.length(),suffix)));
}

bool isDir(const string &inputFilename) {
  struct stat s;
  if( stat(inputFilename.c_str(),&s) == 0 ) {     // If we can open file
    return s.st_mode & S_IFDIR;
  } else {
      cout << "Error opening [" << inputFilename << "]" << endl;
      exit(0);
  }
  return false;
}

// Helper function, you probably want to change this if you need to add options
string getOutputFilenameHelper(const string filenameBase, const SolutionMethod method, const PackingOptions &packingOptions) {

  std::ostringstream outputFilename;

  outputFilename << filenameBase;

  switch (method)   {
  case RECURSIVE_NUMBER_PARTITIONING: outputFilename << RNP_SUFFIX;             break;
  case BIN_COMPLETION               : outputFilename << BC_SUFFIX;              break;
  case BELOV_BCP                    : outputFilename << BELOV_BCP_SUFFIX;       break;
  case MOFFITT                      : outputFilename << MOFFITT_SUFFIX;         break;
  case MOFFITT_RICH                 : outputFilename << MOFFITT_RICH_SUFFIX;    break;
  case MOFFITT_CACHED               : outputFilename << MOFFITT_CACHED_SUFFIX;  break;
  default: cout << "Unknown SolutionMethod in getOutputFilename: " << method <<  endl; exit(1);
  };


  if (packingOptions.useSchroeppelShamir) { outputFilename << SS_STRING; }
  if (packingOptions.classicSort)     	  { outputFilename << CLASSIC_SORT_STRING; }
  if (packingOptions.removePairs)         { outputFilename << PAIRS_STRING;  }
  if (packingOptions.useLDS)              { outputFilename << LDS_STRING; }

  // This is only relelvant if not using SS and not using classic Search
  if (!packingOptions.useSchroeppelShamir && method == BIN_COMPLETION) {
    outputFilename << "_IE" << packingOptions.bufferSize;
  }
  outputFilename << ".txt";
  return outputFilename.str();
}

// For BinPacking

string getOutputFilename(const string &inputFilename, const SolutionMethod method,const PackingOptions &packingOptions, int numPartitions /*= UNSET_INT */) {
  std::ostringstream outputFilename;

  if( isDir(inputFilename)) {
    DIR *dir = opendir (inputFilename.c_str());     // Open the directory

    if (dir != NULL) {                   // Make sure the directory can be opened

      if (numPartitions == UNSET_INT) {                             // For BinPacking
        outputFilename << addTrailingSlash(inputFilename)
                       << "output_all_";
      } else {
        outputFilename << addTrailingSlash(inputFilename)   // For NumberPartitioning
                       << "output_all_" << std::setfill('0') << std::setw(2) << numPartitions;
      }

    } else {
      cout << "Could not open directory [" << dir << "]" << endl;
      exit(0);
    }
  } else {
    outputFilename << getDirOfFile(inputFilename)
                   << "output_"
                   << getFilename(inputFilename);
  }

  return getOutputFilenameHelper(outputFilename.str(), method, packingOptions);
}



// skips "." and ".."  (current dir and parent dir)
// skips all strings beginning with "output_"
bool isInputFile(char *filename) {
  const char outputPrefix[8] = "output_";     // ignore files with this prefix
  return  (filename[0] != '.' &&                                     // Skip the current and parent directory
            strncmp(filename, outputPrefix, strlen(outputPrefix)));   // Skip the output files
}

vector<string> getInputFilenames(const string &inputFilename) {
  vector<string> filenames;   // The filenames to return


  string outputFilename;
  struct dirent *ent;                         // Dir Entry Struct
  if(isDir(inputFilename)) {                   // If the inputFilename is a directory
    DIR *dir = opendir (inputFilename.c_str());       // Open the directory
    while ((ent = readdir (dir)) != NULL) {  // read the files
      if (isInputFile(ent->d_name)) {         // If the file is a valid input file
        string filename = addTrailingSlash(inputFilename);
        filename.append(ent->d_name);
        filenames.push_back(filename);
      }
    }
  } else {
    string x(inputFilename);

    filenames.push_back(x);
  }

  std::sort(filenames.begin(),filenames.end());
  return filenames;
}

size_t countLines(const string filename, string prefix) {
  size_t numLines = 0;
  string line;
  std::ifstream inFile(filename);

  if (inFile) {
    while (std::getline(inFile, line)) {

      if (startsWith(line,prefix)) {
        ++numLines;
      }
    }
  }
  return numLines;
}



