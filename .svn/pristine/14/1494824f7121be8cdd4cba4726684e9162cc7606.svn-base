/*
 * HorowitzSahni.cpp
 *
 *  Created on: May 8, 2014
 *      Author: ethan
 */

#include "HorowitzSahni.hpp"
#include "SubsetSum.hpp"
#include "KK.hpp"
#include "../utils/MemoryUsage.hpp"

namespace ss {

uint64_t executeHS2(const uint64_t S[], const int N, const uint64_t sum) {

  // TODO: include largest element and search for perfect - largest
  // Will require some doing
  uint64_t perfect = (sum+1) / 2;

  uint64_t kkBound = kk(S, N, 2, sum);

  uint64_t upper = getPartitionUpper(kkBound, perfect, sum); 	// Get upper bound
  if (upper < perfect) {  // If cgaBound was perfect, we are done
    return perfect;
  }
  uint64_t lower = sum-upper;	                     // Lower is complement of upper

  vector<uint64_t> a;                         // all subset sums from first half of numbers
  vector<uint64_t> b;                         // all subset sums from second half of numbers

  generateAllSums(S,  a, 0    , N/2-1  ,true);   // combinations of 1st half of numbers (sorted ascending)
  generateAllSums(S,  b, N/2  , N-1    ,false);  // combinations of 2nd quarter of numbers (sorted descending)

  auto bIt = b.begin();             // Iterator to b list
  uint64_t bValue = *bIt;
  bIt++;

  for (uint64_t aValue : a) {       	// For each element of a
    uint64_t abSum = aValue + bValue; // sum of a and b

    while (abSum > lower && bIt != b.end()) {
    	bValue = *bIt;																				// Store the next b value
    	bIt++;																								// Increment the iterator
    	abSum = aValue + bValue;															// Compute the sum

    	if (abSum <= upper) {																	// If the sum <= upper bound, compute new bounds
  			upper = getPartitionUpper(abSum, perfect, sum);    	// Computer new upper bound from absum
  			if (upper < perfect) {                              // If new absum was perfect, we are done
  				return perfect;
  			}
  			lower = abSum-upper;                                // Lower is complement of upper
    	}
    }

    if (abSum >= lower) {	// This happens when we run out of elements in b, check remaining pairs with changing a
    	if (abSum <= upper) {																	// If also <= upper, then we have a new bound
  			upper = getPartitionUpper(abSum, perfect, sum);    	// Computer new upper bound from absum
  			if (upper < perfect) {                              // If new absum was perfect, we are done
  				return perfect;
  			}
  			lower = abSum-upper;                                // Lower is complement of upper

    	} else {	// If abSum > upper, increasing a will not help
    		break;	// so we are done
    	}
    }
  }
  return upper+1;                                 // return the number of subset sums stored in ALLSUMS
}

}
