
#include "PackingUtils.hpp"
#include "ProgramOptionsUtils.hpp"

#include <iostream>                 // for std::cout
#include <boost/filesystem.hpp>     // includes all needed Boost.Filesystem declarations
#include <vector>
#include <algorithm>                // for sort
#include <fstream>
#include <sstream>
#include <boost/program_options.hpp>
#include <sys/stat.h>
using namespace boost;
namespace po  = boost::program_options;
namespace bfs = boost::filesystem;


using std::cout;
using std::endl;
using std::vector;
using std::string;

bfs::directory_iterator g_endIt; // default construction yields past-the-end

void getAllDirectories( const bfs::path & dirPath, vector<bfs::path> &dirs)      // placing path here if found
{
  if ( !exists( dirPath ) )
    return;


  for ( bfs::directory_iterator it( dirPath ); it != g_endIt; ++it ) {

    if ( is_directory(it->status()) ) {
      getAllDirectories( it->path(),dirs);
    } else {
      dirs.push_back(dirPath);
      return;
    }
  }
}

// Process an output_... file
vector<int> processOutput(string filename) {

  vector<int> numBinsVector;
  std::ifstream inFile(filename);

  if (inFile) {   // If the file exists
    string line;

    cout << "Filename: " << filename << endl;


    while (std::getline(inFile, line)) {

      std::stringstream  lineStream(line);
      string        cell;
      string problemName;
      string timeString;
      string numNodesString;
      string numBinsString;
      string sumString;
      string lBoundString;

      std::getline(lineStream,problemName,',');
      std::getline(lineStream,timeString,',');
      std::getline(lineStream,numNodesString,',');
      std::getline(lineStream,numBinsString,',');
      std::getline(lineStream,sumString,',');
      std::getline(lineStream,lBoundString,',');


      numBinsVector.push_back(atoi(numBinsString.c_str()));
    }

  }

  inFile.close();

  return numBinsVector;
}

// Replace toReplace with replaceWith in the string s
string replace(string s, string toReplace,  string replaceWith) {

    return(s.replace(s.find(toReplace), toReplace.length(), replaceWith));
}

// Recursively make dir
void mkdir(string dir) {
  dir = addTrailingSlash(dir);
  umask(0);               // Set the umask for mkdir to have correct permissions
  const char SEPARATOR[2] = "/";

  size_t separatorIdx = dir.find(SEPARATOR,0,1);
  while (separatorIdx!=string::npos) {
    cout << "Make: " << dir.substr(0,separatorIdx).c_str() << endl;
    mkdir(dir.substr(0,separatorIdx).c_str(), 0776);
    separatorIdx=dir.find(SEPARATOR,separatorIdx+1,1);
  }
}

int main(int argc,char*argv[]) {

  string datPacking = UNSET_STRING;
  int N = UNSET_INT;

  po::options_description commandOptions("Options");
  commandOptions.add_options()
  ("help,h", "produce help message")
  ("N,n"   , po::value< int >(&N), "(required) The number of items per problem")
  ("file,f", po::value< string >(&datPacking), "(required) The path to dat/packing.");

  std::ostringstream helpOut;
  helpOut << endl << "Usage: " << argv[0] << " [options]" << endl << endl << commandOptions << endl;
  try {
    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, commandOptions), vm);
    po::notify(vm);

    optionRequired("N",N,UNSET_INT);
    optionRequired("file",datPacking,UNSET_STRING);

    if (argc == 1 || vm.count("help")) { cout << helpOut.str(); return 0; }
  } catch(std::exception& e) {
    cout << helpOut.str() << "*** ERROR: " << e.what() << endl << endl;
    return 1;
  }

  std::ostringstream out;
  out << addTrailingSlash(datPacking) << N << "/";

  bfs::path p (out.str());

  vector<bfs::path> dirs;
  getAllDirectories(p,dirs);

  // ========================
  // Iterate through the dirs
  // ========================
  for (size_t i=0;i<dirs.size();i++) {

    bfs::path &currentDir = dirs[i];
    cout << "-------------------------" << endl;
    cout << currentDir.string() << endl;

    vector<bfs::path> files;
    for ( bfs::directory_iterator it( currentDir ); it != g_endIt; ++it ) {
      files.push_back(*it);
    }
    std::sort(files.begin(),files.end());



    // ============================================================
    // First look through output_* files and store optimalSolutions
    // in optimalSolutionsVec. Compare among all the solutions, i.e.
    // Belov or BC or BC Classic
    // ============================================================

    vector<string> problemFiles;
    vector<vector<int> > optimalSolutionsVec;
    size_t maxLength = 0;                          // The most solutions of any solver, should be N
    for (size_t i=0;i<files.size();i++) {
      if (files[i].filename().string()[0] == 'o') {
        optimalSolutionsVec.push_back(processOutput(files[i].string()));
        if (optimalSolutionsVec.back().size() > maxLength) {
          maxLength = optimalSolutionsVec.back().size();
        }
      } else if (files[i].filename().string()[0] == 'p') {
        problemFiles.push_back(files[i].string());    // Problem file
      }
    }

    // Verify that we have solutions for all the problems
    if (maxLength != problemFiles.size()) {
      cout << "ERROR: Incomplete solutions for " << currentDir << endl;
      cout << "# Problem Files: " << problemFiles.size() << endl
           << "# Solutions    : " << maxLength << endl << endl;
      exit(0);
    }

    std::sort(problemFiles.begin(), problemFiles.end());


    // ==============================================
    // Fill in the optimal solutions for each problem
    // ==============================================
    vector<int> optimalSolutions; // fill this in
    optimalSolutions.resize(maxLength,-1);
    for (size_t i=0;i<maxLength;i++) {
      for (size_t j=0;j<optimalSolutionsVec.size();j++) {
        vector<int> &v = optimalSolutionsVec[j];
        if (v.size() > i) {
          if (optimalSolutions[i] == -1) {
            optimalSolutions[i] = v[i];
          } else if (optimalSolutions[i] != v[i]) {
            cout << "ERROR, INCONSISTENT VALUES!" << endl;
            exit(0);
          }
        }
      }
    }

    // =======================
    // Create Packing Problems
    // =======================

    const string PACKING = "packing";
    const string PARTITIONING = "partitioning";
    mkdir(replace(currentDir.string(),PACKING,PARTITIONING));
    for (size_t i=0;i<problemFiles.size();i++) {
      cout << "Input : " << problemFiles[i] << endl;
      string outputFilename(replace(problemFiles[i],PACKING,PARTITIONING));

      BinPackingProblem bpProblem(problemFiles[i]);

      cout << "Output: " << outputFilename << endl << endl;
      std::ofstream outFile(outputFilename);

      outFile << bpProblem.problemName << endl
              << optimalSolutions[i] << " " << bpProblem.N << " " << bpProblem.sum << endl;
      for (int j=0;j<bpProblem.N;j++) {
        outFile << bpProblem.S[j] << endl;
      }
      outFile.close();
    }




  }

    return 0;
}
