/*
 * CachedSets.hpp
 *
 *  Created on: Dec 23, 2013
 *      Author: ethan
 */

#ifndef CACHEDSETS_BUFFERED_HPP_
#define CACHEDSETS_BUFFERED_HPP_

#include "PartitionUtils.hpp"
#include "../ss/extended/Schroeppel_Shamir_M_Subsets.hpp"					// For subclass
#include "../ss/extended/HorowitzSahniLowCardinalityMSubsets.hpp" 	// For subclass
#include "../Utils.hpp"

namespace partition {

// ============================================================================
//
// C a c h e d S e t s B u f f e r e d
//
// CachedSetsBuffered is abstract, generateSets(...) is pure virtual
//
// ============================================================================
class CachedSetsBuffered {
	protected :

		uint64_t m_elementsSum;
		int m_K;

		SetVector m_smallSets;      		// The sets < perfect generated by Schroeppel and Shamir
		SetVector m_largeSets;      		// The sets > perfect generated by Schroeppel and Shamir
		size_t m_smallSetIdx;       		// The idx into m_smallSets
		size_t m_largeSetIdx;       		// The idx into m_largeSets

		SetIterator m_currentMax; 			// The next max value to try, taken from m_maxHeap
		SetIterator m_currentMinBegin;	// The beginning of the next min values to try, taken from m_minHeap
		SetIterator m_currentMinEnd;		// The beginning of the next min values to try, taken from m_minHeap

		double m_generationTime;	 		  // The time spent generating sets (with SS or HS)
		size_t m_generationCalls;			  // The number of subset generation calls (with SS or HS)

	protected :
		// Generate the next m_numSets sets  with sum above perfect
		// and the corresponding sets with sum below perfect
		void generateSets();

		// Virtual function which calls SS or HS in child classes
		virtual void generateSets(SetVector &smallSets, SetVector &largeSets)=0;
	public :
		CachedSetsBuffered(const uint64_t S[], const int N, const int K, uint64_t upperBound, size_t numSets);

		virtual ~CachedSetsBuffered();
		// Get the next subset, call for each iterative weakening iteration
		// Return true if another set exists, false otherwise
		bool next();

		// Get the max subset in range
		SetIterator getMax() const {
			return m_currentMax;
		}

		// Get the subsets with sum below perfect in range
		SetIteratorPair getMinRange() const {
			return SetIteratorPair(m_currentMinBegin,m_currentMinEnd);
		}

		// ---------------
		// Debugging Calls
		// ---------------

		// Number of times Schroeppel and Shamir was called
		size_t getGenerationCalls() const;

		// Amount of time spent running Schroeppel and Shamir
		double getGenerationTime() const;
};

// ============================================================================
//
// S u b c l a s s e s
//
// ============================================================================

// ----------------------------------------------------------------------------
//
// C a c h e d S e t s B u f f e r e d S S
//
// ----------------------------------------------------------------------------
class CachedSetsBufferedSS : public CachedSetsBuffered {
	private :

		ss::SchroeppelShamirMSubsets m_ssms;

	protected :
    void generateSets(SetVector &smallSets, SetVector &largeSets);
	public :
		CachedSetsBufferedSS(const uint64_t S[], const int N, const int K, uint64_t upperBound, size_t numSets);

};

// ----------------------------------------------------------------------------
//
// C a c h e d S e t s B u f f e r e d L o w C a r d i n a l i t y H S
//
// ----------------------------------------------------------------------------

class CachedSetsBufferedLowCardinalityHS : public CachedSetsBuffered {
private :

  ss::HorowitzSahniLowCardinalityMSubsets m_hslcms;

protected :
  void generateSets(SetVector &smallSets, SetVector &largeSets);
public :
    CachedSetsBufferedLowCardinalityHS(const uint64_t S[], const int N, const int K,
          uint64_t upperBound, size_t numSets, const size_t maxCardinality);
};


}
#endif /* CachedSETS_HPP_ */
