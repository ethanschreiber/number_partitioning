/* This program finds optimal solutions to the bin-packing problem.  The bins
 are of size BINCAP, the elements are chosen uniformly from zero to BINCAP-1, and
 are sorted in decreasing order of size.  The best-fit decreasing solution is
 used as an initial upper bound, and the L2 lower bound is used as the initial
 lower bound.  The algorithm takes each element in turn, assigns it to its own
 bin, and computes all undominated completions of that bin, branching if there
 are more than one.  The feasible subsets are generated by recursively traversing
 a binary tree, and then each are tested individually to see if they would be
 dominated by another.  Completions occur in non-decreasing order of element size.
 It chooses first the undominated set with the largest sum. The undominated sets
 themselves are not sorted, but rather an array of indices to them is sorted.  If
 it reaches a state where all the elements that could possibly fit in the bins
 already processed have been placed, then all branching points down to that depth
 become moot, since we can't do any better.  As we complete each bin, the
 accumulated residual capacity is wasted space, and is used as part of a lower
 bound.  The overall algorithm is a single branch-and-bound depth-first
 search. This version does nogood pruning, and eliminates nogoods that are no
 longer relvant. Written by Richard E. Korf, University of California,
 Los Angeles .*/

#include "BinCompletion.hpp"

#include <stdio.h>                                    // standard I/O library
#include <math.h>                                     // mathematical library
#include <stdlib.h>
#include <stdint.h>
#include <iomanip>
#include <string>
#include <algorithm>
#include <cassert>
using std::string;
using std::vector;

// ==============================
// Global Variables For This File
// ==============================
static uint64_t 	g_binCap;         // capacity of the individual bins
static uint64_t 	g_binCapHalf;     // BINCAP/2
static int 	 	    g_N;              // number of values to be packed
static uint64_t 	g_S[MAXN]; 		    // array of elements to be partitioned
static SetNodeVector 	  g_bin[MAXN];      // the set of elements in each bin
static int 		    g_solution[MAXN]; // bin index of each element in best solution found so far
static uint64_t 	g_maxUsed;        // The max capacity used in any bin
static uint64_t 	g_sum;            // sum of all elements
static int 		    g_upperBound;     // the number of bins used in the best solution found so far
static uint64_t 	g_allowedWaste;   // maximum waste allowed: bestsofar*BINCAP-sum of elements
static int 		    g_minBins;        // number of elements > 1/2
static uint64_t   g_nodes;          // number of calls to search routine
static int 		    g_lowerBound;     // lowerbound based on wasted space

static bool g_useLDS;              // Should  we use Limited Discrepancy search?
static bool g_useSchroeppelShamir; // Should we use schroeppel and shamir?
static bool g_removePairs;         // Should we remove pairs as a preprocessing step?
static bool g_classicSort;         // Should we perform the classic Korf search?
static int g_IEBufferSize;         // The inclusion/exclusion buffer size, can't set g_isClassicSearch or g_useSchroppelShamir or this is ignored

// =====================================================================================================
// Generate a CompletionGenerator. Make sure to delete the pointer returned after you are done using it!
// =====================================================================================================
inline ss::CompletionGenerator* createCompletionGenerator(const SumArray<uint64_t> &remaining, const uint64_t waste, const uint64_t residualCap) {

  // If not using schroppel and shamir or we have only 16 or fewer items left, use buffered
  // inclusion/exclusion where we read in g_IEBUfferSize elements at a time (set on command line)
  // and sort them by sum breaking ties by cardinality
  if (!g_useSchroeppelShamir || remaining.size() < 16) {
    ss::IECompletionGenerator *ieCompletionGenerator  = new ss::IECompletionGenerator(
        residualCap + waste - g_allowedWaste, residualCap, remaining.begin(), remaining.size(), remaining.sum(),true);

    return new ss::BufferedCompletionGenerator(ieCompletionGenerator,g_IEBufferSize,g_classicSort);

  } else { // Else we use Schroppel and Shamir

    // TODO: Special case for REALLY low lower bound?
    // i.e., lBoundSS can be less than 0, SS is not necessary then
    uint64_t lBoundSS = std::max((uint64_t) 1, residualCap + waste - g_allowedWaste); // lower bound on sum of bin completions
    uint64_t uBoundSS = residualCap;
    return new ss::SSCompletionGenerator(remaining.begin(), remaining.size(), lBoundSS, uBoundSS, false);
  }
}

// ============================================================================
// SEARCH  finds an optimal completion of the corresponding partial solution.
// The solution is left encoded in the BIN array, and it returns true if it finds an
// optimal solution, and false otherwise.  It performs a single depth-first
// branch-and-bound search.
// ============================================================================
bool search(const int binIdx,              // the index of the next bin to be completed
		        const uint64_t waste,          // the total amount of bin capacity wasted in previous bins
		        SumArray<uint64_t> &remaining, // vector of elements < 1/2 bin capacity
		        int numDiscrepencies,          // For Limited Discrepency Search
		        vector<SetNodeVector> &noGoods) {    // nogood sets for this call

	g_nodes++;                               // count total calls to search routine

	// ----------------------------------------------------------------------
	// 1. First put the largest remaining element into the bin.
	// The first b numbers in g_elements (which is sorted in descending order
	// with size > half of the bin capacity are put into the first b bins.
	// After we put an item in a bin, we then try to complete the bin.
	// ----------------------------------------------------------------------

	// These variables to be set by the following if/else statement
  uint64_t residualCap;                // residual capacity of bin to be completed

	if (g_S[binIdx] > g_binCapHalf) {       // If this bin contains an element > 1/2 capacity
									                        // It was added to g_bin in executeBP function already
		residualCap = g_binCap - g_S[binIdx]; // remaining residual capacity after large element

		if (!remaining.empty() &&
		    remaining.lastElement() > residualCap) {        // smallest cannot fit in this bin so none can,
			return search(binIdx + 1, waste + residualCap,    //  go to next bin
			              remaining, numDiscrepencies, noGoods);
		}
	} else {                                // < 1/2 full, next remaining will always fit!
	  uint64_t val = remaining.pop_front();  // Pop first element and get value
		residualCap = g_binCap - val;         // remaining capacity of this bin af
		g_bin[binIdx].replaceWith(val);       // assign largest remaining element to this bin
	}

  if (remaining.empty()) {    // no numbers remain, found optimal solution

    processSolution(g_maxUsed, g_allowedWaste, g_upperBound, g_N,
        g_binCap, g_lowerBound, g_sum, g_bin, binIdx + 1,
        g_solution, g_S, g_minBins);     // process solution

    return true;
  }
	// ------------------------------------------------------------
	// 2. Generate the completions for the bin then iterate through
  //    each undominated completion and recurse on each.
	// ------------------------------------------------------------

	ss::CompletionGenerator *completionGenerator = createCompletionGenerator(remaining,waste,residualCap);

	SetNodeVector currentSet;
	bool returnValue = false;
	int previousCardinality = UNSET_INT; // for limited discrepency search

	while (completionGenerator->next(currentSet)) { // for each undominated feasible completion

		if (g_useLDS) {
		  int currentCardinality = currentSet.cardinality() ;
			if (previousCardinality != UNSET_INT &&           // If not first completion AND
			    currentCardinality > previousCardinality) {   // the cardinality is greater than the last cardinality
				if (numDiscrepencies == 0) {
					break;           // return false but cleanup first
				} else {
					numDiscrepencies--;
				}
			}

			previousCardinality = currentCardinality;   // For next comparison
		}

		if (waste + residualCap - currentSet.sum > g_allowedWaste) {
			break; // in case g_allowedwaste decreased
		}

    vector<SetNodeVector> newNoGoods;        // nogood sets for recursive calls
		currentSet.push_sentinel();        // add sentinel value for nogood call
		bool isNoGood = checkNoGood(currentSet, noGoods, binIdx, newNoGoods, g_bin);

		// ---------------------------------------
		// Fill in newRemaining for recursive call
		// ---------------------------------------
		if (!isNoGood) {
		  SumArray<uint64_t> newRemaining;         // array of remaining elements for recursive call
			int setIdx = 0;             // pointer to members of set
			g_bin[binIdx].resize(1);    // 1 element was filled above, rest we truncate and fill from undominated set

			// -----------------------------------------------------
			// Partition the remaining elements into:
			//   1. The current bin as a completion.
			//   2. The new remaining elements array.
			// -----------------------------------------------------
			for (size_t j = 0; j < remaining.size(); j++) {     // for each previous remaining element
				if (remaining[j] == currentSet.member[setIdx]) {  // found this element
					g_bin[binIdx].push_back(remaining[j]);          // Add member
					setIdx++;                                       // look for next element
				} else {                                          // element not in set
					newRemaining.push_back(remaining[j]);           // copy into newRemaining array
				}
			}

			if (newRemaining.empty()) { // If no elements left, process the solution.

        if (processSolution(g_maxUsed, g_allowedWaste, g_upperBound, g_N,
                            g_binCap, g_lowerBound, g_sum, g_bin, binIdx + 1,
                            g_solution, g_S, g_minBins)) {
          returnValue = true;
          break;                  // return true but cleanup first
        }
      } else {                    // If elements remaining, recurse
				bool result = search(binIdx + 1, (waste + residualCap - currentSet.sum),
				                     newRemaining, numDiscrepencies, newNoGoods);

				if (result ||
				    (g_S[binIdx] > g_binCapHalf &&
				     (newRemaining.empty() || newRemaining.lastElement() > residualCap))) {
					returnValue = true;
					break;             // return true but cleanup first
				}
			}

			noGoods.push_back(currentSet); // store this set completion as a nogood
		}
	}

	delete completionGenerator;
	return returnValue;
}


// ============================================================================
// This function:
//    - removes perfect pairs (x+y == capacity)
//    - Sets N  and totalSum
// ============================================================================
int preprocess(const BinPackingProblem &problem, int &N,
		           uint64_t &totalSum, PairVector &perfectPairs, bool doRemovePairs) {

  BinPackingProblem processedProblem(problem.capacity);
  int pairsRemoved;
  if (doRemovePairs) {
    pairsRemoved = removePairs(problem,processedProblem,perfectPairs);
    N = processedProblem.N;
    totalSum = processedProblem.sum;
    memcpy(g_S,processedProblem.S,sizeof(uint64_t) * N);
  } else {
    pairsRemoved = 0;
    N = problem.N;
    totalSum = problem.sum;
    memcpy(g_S,problem.S,sizeof(uint64_t) * N);
  }

  return pairsRemoved;
}

// ============================================================================
// execute reads the input file , prints out the elements, solves the problem,
// and prints out the solution and statistics.
// ============================================================================

void executeBP(const BinPackingProblem &problem, ProblemStats &stats,
               const PackingOptions &packingOptions) {

  g_useLDS              = packingOptions.useLDS;
	g_useSchroeppelShamir = packingOptions.useSchroeppelShamir;
	g_removePairs         = packingOptions.removePairs;
	g_classicSort  		    = packingOptions.classicSort;
	g_IEBufferSize        = packingOptions.bufferSize;

	assert(problem.S[0] > problem.S[problem.N - 1] &&
	       "problem.S not sorted in descending order!");

	SumArray<uint64_t> smallElements;    // vector of elements <= 1/2

	SimpleTimer timer; // start timing

	// ----------------------------------------------
	// Initialize problem variables
	// ----------------------------------------------

	// Preprocess pairs and set g_S, g_N and g_sum
	PairVector perfectPairs; // The perfect pairs
	int pairsRemoved = preprocess(problem, g_N, g_sum,perfectPairs,g_removePairs);

	g_binCap     = problem.capacity;
	g_binCapHalf = g_binCap / 2;
	g_nodes      = 0;                                   // initialize node counter


	g_lowerBound = (problem.lowerBound == -1) // If lower bound not specified
			? L2(g_S, g_N, g_binCap, g_sum)				// minimum bins based on wasted space
			: problem.lowerBound;       					// else use specified value

	g_upperBound = BFD(g_S, g_solution, g_N, g_binCap); // compute best-fit decreasing solution

	stats.sum             = problem.sum;                // and sum
	stats.lowerbound      = g_lowerBound+pairsRemoved;  // For reporting the initial lower bound
	stats.numPerfectPairs = pairsRemoved;

	// ------------------
	// Perform the search
	// ------------------

	if (g_lowerBound < g_upperBound) { // bfd solution is not optimal, have to search

		g_allowedWaste = (g_upperBound - 1) * g_binCap - g_sum; // only look for better solutions
		g_minBins      = 0;                   // number of bins for elements > 1/2

		for (int i = 0; i < g_N; i++) {       // for each element
			if (g_S[i] > g_binCapHalf) {        // elements > C/2 get their own bins
				g_bin[i].replaceWith(g_S[i]);
				g_minBins++;                      // increment minimum number of bins needed
			} else if (g_S[i] > 0){             // Don't add zero elements
				smallElements.push_back(g_S[i]);  // element is available to assign
			}                                   // increment number of such elements
		}

		if (smallElements.size() > 0) { // if there are any elements <= ONEHALF
			if (g_useLDS) {
				for (int numDiscrepencies = 0; numDiscrepencies < 25;	numDiscrepencies++) {
					vector<SetNodeVector> nogoods; // dummy stack of nogood sets for top-level call
					bool result = search(0, 0, smallElements, numDiscrepencies, nogoods); // start with no bins, no waste, and no nogoods
					if (result) {
						break;
					}
				}
			} else {
				vector<SetNodeVector> nogoods; // dummy stack of nogood sets for top-level call
				search(0, 0, smallElements, 0, nogoods); // start with no bins, no waste, and no nogoods
			}
		}
	}

	// ---------------------------
	// Finish timing and set stats
	// ---------------------------

	stats.time       = timer.timeElapsed();
	stats.numNodes   = g_nodes;
	stats.numBins    = g_upperBound + pairsRemoved;
	stats.maxCapUsed = g_maxUsed;

	// --------------------------------------------------------------------------
	// PRINT SOLUTION!
	// --------------------------------------------------------------------------
	if (packingOptions.printSolution)
	{
		vector<uint64_t> *binCompletions = new vector<uint64_t> [g_upperBound];
		uint64_t *sums = new uint64_t[g_upperBound];
		memset(sums, 0, sizeof(uint64_t) * g_upperBound);
		cout << "-------------------------------------------" << endl;
		cout << "Solution: " << endl;
		for (int i = 0; i < g_N; i++) {

			binCompletions[g_solution[i]].push_back(g_S[i]);
			sums[g_solution[i]] += g_S[i];
		}

		for (int i = 0; i < g_upperBound; i++) {
			cout << "bin " << i << " (" << sums[i] << ") ";
			for (size_t j = 0; j < binCompletions[i].size(); j++) {
				cout << binCompletions[i][j] << " ";
			}
			cout << endl;
		}

    for (size_t i = 0; i < perfectPairs.size(); i++) {
        cout << "bin " << g_upperBound + i << " (" << perfectPairs[i].first + perfectPairs[i].second << ") "
             << perfectPairs[i].first << " " << perfectPairs[i].second << endl;

    }
		cout << "-------------------------------------------" << endl;
		delete[] binCompletions;
		delete[] sums;
	}
}

