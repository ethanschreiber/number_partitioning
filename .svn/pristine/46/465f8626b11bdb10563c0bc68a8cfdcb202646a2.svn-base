/*
 * Schroeppel_Shamir.cpp
 *
 *  Created on: Oct 2, 2012
 *      Author: ethan
 */

#include "SchroeppelShamir.hpp"
#include "HorowitzSahni.hpp"
#include "KK.hpp"
#include "../utils/MemoryUsage.hpp"
#include  <iostream>
#include <iomanip>
using std::cout;
using std::endl;

namespace ss {


// ============================================================================
//
// Schroeppel and Shamir Helper Functions *** SETS ***
//
// ============================================================================

void initializeSets(const uint64_t S[MAXN], const int n,
                           vector<SetNodeBitset> &a,vector<SetNodeBitset> &b,vector<SetNodeBitset> &c,vector<SetNodeBitset> &d) {
  generateAllSets(S, n, a, 0    , n/4-1  ); // combinations of 1st quarter of numbers
  generateAllSets(S, n, b, n/4  , n/2-1  ); // combinations of 2nd quarter of numbers
  generateAllSets(S, n, c, n/2  , n*3/4-1); // combinations of 3rd quarter of numbers
  generateAllSets(S, n, d, n*3/4, n-1    ); // combinations of 4th quarter of numbers

}
void initializeHeaps(vector<SetNodeBitset> &a,vector<SetNodeBitset> &b,vector<SetNodeBitset> &c,vector<SetNodeBitset> &d,
                     SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {

  // --------------------------------------------------------------------------
  //construct min heap of initial combinations of sets from array A and array B
  // --------------------------------------------------------------------------

  for (size_t aIndex = 0; aIndex < a.size() && a[aIndex].sum() <= upper; aIndex++) {  // for each set in A array
    abheap.vector_push_back(SSHeapNode(aIndex,      // aptr pointer is same as index
                                0,           // smallest value of bsums is first element
                                a[aIndex])); // b.front().sum == 0 --> [a[index].sum + b.front().sum] == a[index].sum,
  }

  abheap.make_heap();


  // --------------------------------------------------------------------------
  //construct max heap of initial combinations of sets from array C and array D
  // --------------------------------------------------------------------------

  int dIndex = d.size() - 1;                  // index to largest value in dsums

  for (size_t cIndex = 0; cIndex < c.size(); cIndex++) {  // process csums in increasing order
    if (c[cIndex].sum() > upper) {
      break;                                    // no more entries to add to heap
    }

    while (c[cIndex].sum() + d[dIndex].sum() > upper) {
      dIndex--;
    }

    cdheap.
      vector_push_back(SSHeapNode(cIndex,                    // cpointer is index
                     dIndex,                          // largest value of dsums <= target
                     c[cIndex].sum() + d[dIndex].sum())); // sum of heap element
  }

  cdheap.make_heap();
}

void initialize(const uint64_t S[MAXN], const int n,
                vector<SetNodeBitset> &a,vector<SetNodeBitset> &b,vector<SetNodeBitset> &c,vector<SetNodeBitset> &d,
                       SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {


  initializeSets(S,n,a,b,c,d);
  initializeHeaps(a,b,c,d,abheap,cdheap,upper);
}


// ============================================================================
//
// Schroeppel and Shamir Helper Functions *** SUMS ***
//
// ============================================================================

void initializeSets(const uint64_t S[MAXN], const int n,
                    vector<uint64_t> &a,vector<uint64_t> &b,vector<uint64_t> &c,vector<uint64_t> &d) {

	generateAllSums (S, a, 0    , n/4-1);   // combinations of 1st quarter of numbers
	generateAllSums (S, b, n/4  , n/2-1); // combinations of 2nd quarter of numbers
	generateAllSums (S, c, n/2  , n*3/4-1); // combinations of 3rd quarter of numbers
	generateAllSums (S, d, n*3/4, n-1); // combinations of 4th quarter of numbers


}
void initializeHeaps(vector<uint64_t> &a,vector<uint64_t> &b,vector<uint64_t> &c,vector<uint64_t> &d,
                     SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {


	// --------------------------------------------------------------------------
	//construct min heap of initial combinations of sets from array A and array B
	// --------------------------------------------------------------------------

	for (size_t index = 0; index < a.size() && a[index] <= upper; index++) {  // for each set in A array
		abheap.vector_push_back(SSHeapNode(index,          // aptr pointer is same as index
													0,                    // smallest value of bsums is first element
													a[index]));           // a[index].sum + b.front().sum, b.front().sum = 0
		}
		abheap.make_heap();   // make the heap


		// --------------------------------------------------------------------------
		//construct max heap of initial combinations of sets from array C and array D
		// --------------------------------------------------------------------------

		int dIndex = d.size() - 1;                      // index to largest value in dsums

		for (size_t cIndex = 0; cIndex < c.size(); cIndex++) {  // process csums in increasing order
			if (c[cIndex] > upper) {
				break;                                    // no more entries to add to heap
			}

			while (c[cIndex] + d[dIndex] > upper) {
				dIndex--;
			}

			cdheap.
				vector_push_back(SSHeapNode(cIndex,                     // cpointer is index
											 dIndex,                  // largest value of dsums <= target
											 c[cIndex] + d[dIndex]));  // sum of heap element
		}
		cdheap.make_heap();
}

void initialize(const uint64_t S[MAXN], const int n,
                vector<uint64_t> &a,vector<uint64_t> &b,vector<uint64_t> &c,vector<uint64_t> &d,
                SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {

  initializeSets(S,n,a,b,c,d);
  initializeHeaps(a,b,c,d,abheap,cdheap,upper);
}


// ============================================================================
//
// Schroeppel and Shamir Partition Algorithm
//
// ============================================================================


uint64_t executeSS2(const uint64_t S[], const int N, const uint64_t sum) {

  // TODO: include largest element and search for perfect - largest
  // Will require some doing
  uint64_t perfect = (sum+1) / 2;

  // Put first element in first subset
  uint64_t kkBound = kk(S, N, 2, sum);

  uint64_t upper = getPartitionUpper(kkBound, perfect, sum); 	// Get upper bound
  if (upper < perfect) {  // If cgaBound was perfect, we are done
    return perfect;
  }
  uint64_t lower = sum-upper;	           // Lower is complement of upper

  vector<uint64_t> a;    // all subset sums from first quarter of numbers
  vector<uint64_t> b;    // all subset sums from second quarter of numbers
  vector<uint64_t> c;    // all subset sums from third quarter of numbers
  vector<uint64_t> d;    // all subset sums from fourth quarter of numbers

  SSMinHeap abheap;    				// Min Heap Comparator
  SSMaxHeap cdheap;   				// Max Heap Comparator

  deque<SSHeapNode> cdlist;   // list of subset sums removed from CD heap

  // Initialize the 4 vectors and 2 heaps
  initialize(S,N,a,b,c,d,abheap,cdheap,upper);

  double vm,resident_set;
  process_mem_usage(vm,resident_set);
  cout << "Mem: " << vm << endl
  		 << "res: " << resident_set << endl << endl;

  while (!abheap.empty()) {                      // until AB heap is empty

      // add new sets to list with sums within bounds
      uint64_t topsum = cdheap.front().sum() + abheap.front().sum();     //sum of elements on top of heaps

      ETHAN: is topsum>= lower correct?
      while (!cdheap.empty() && topsum >= lower) {            // new set within bounds

        if (cdheap.front().y() > 0) {                         // there is another element in this column
          SSHeapNode newElement(cdheap.front().x(),           // keep same row
                                cdheap.front().y() - 1,       // replace with next combination in column
                                c,d);                         // sum is c[x] + d[y]

          cdheap.pop();                                       // Remove old head

          cdheap.push(newElement);                            // add new element to heap vector

        } else {                                              // no more elements in this column
          cdheap.pop();                                       // Remove old head
        }
        if (topsum <= upper) {                                // if this value is better than best so far
          upper = getPartitionUpper(topsum, perfect, sum);    // Computer new upper bound from topsum
          if (upper < perfect) {                              // If new topsum was perfect, we are done
            return perfect;
          }
          lower = sum-upper;                                  // Lower is complement of upper
        }
        topsum = cdheap.front().sum() + abheap.front().sum(); // sum of two top elements of heaps
      }

      if (abheap.front().y() < b.size() - 1) {                // there is another element in this column

        SSHeapNode newHeapNode(abheap.front().x(),            // replace with next combination in this column
                               abheap.front().y() + 1,
                               a,b);  // sum of new subset

        abheap.pop();
        abheap.push(newHeapNode);
      } else {                                                // Otherwise just pop node
        abheap.pop();
      }
    }

    return upper+1;   // Best is always 1 more that upper bound

}


} // end namespace
