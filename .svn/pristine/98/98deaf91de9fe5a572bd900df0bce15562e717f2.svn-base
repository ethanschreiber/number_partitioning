/* This program optimally solves arbitrary K-way partitioning problems
   using the extended Schroeppel and Shamir algorithm and recursive
   partitioning.  The objective function is to minimize the maximum
   subset sum.  First, the KK heuristic is used to compute an
   approximate K-way partition.  Then, if K is even, all the numbers
   are partitioned approximately in half, and then each half is
   recursively partitioned K/2 ways.  Alternatively, if K is odd, all
   the numbers are partitioned two ways into subsets that approximate
   floor(K/2)/K and ceil(K/2)/K of the total sum, and each partition
   is recursively partitioned floor(K/2) and ceil(K/2) ways,
   respectively. This version uses a dedicated routine for 2-way KK
   partitioning, and global data structures for full 2-way
   partitioning.  If K is even, this version first partitions the
   subset with fewer elements. This version uses CKK for 2-way
   partitioning if there are less than 17 elements. This version uses
   CGA3 for 3-way partitioning if there are less than 13 elements.
   This version uses CGA4 for 4-way partitioning if there are less
   than 15 elements. This version uses CGA5 for 5-way partitioning if
   there are less than 17 elements. After any split, this version
   first subpartitions the subset with the fewer number of
   elements. When dividing a K-way partition at the top level into
   subsets that will eventually be split into K1 and K2 subsets where
   K1+K2=K and K1<=K2, this version generates the K2-way subset first,
   and excludes the largest K1 numbers from this subset, to reduce the
   number of duplicates that differ by a permutation of the subsets.
   This version narrows the bounds when a subpartition finds a
   solution with a maximum subset sum less than the global best
   solution. This version uses 48-bit integers. This version processes
   the subsets popped off the CD heap in order, rather than in reverse
   order. This version integrates the faster twopart Schroeppel and
   Shamir algorithm that eliminates duplicate nodes, and also tries to
   optimize PART by not inserting subsets into the CD heap if their
   sum is too large.  */

// Modifications from Rich's version
//
// long long -> int64_t
// global vars to static
// Change var new -> newNumber
// Removed comments causing errors (/*  /* */ )
// sums[head1] = tsums[head1++]; -> sums[head1] = tsums[head1]; head1++;
// change function signature from old style to new
// Add void to functions that dont have it
// Remove RNP
// MAXN -> MAX_RNP
// Plus more

#include "PackingUtils.hpp"
#include <stdio.h>                                    /* standard I/O library */
#include <math.h>                                     /* mathematical library */
#include <stdint.h>                                   /* for int64_t */
#include <stdlib.h>                                   /* For exit */
#include <iostream>

#define MAXK 25         /* maximum number of subsets to partition values into */
#define MAX_RNP 52                 /* maximum number of values being partitioned */
#define MAXSETS 8192 /* maximum number of values being partitioned 2^(MAX_RNP/4) */
#define MAXLIST 1000000                            /* maximum size of cdlists */
#define INITSEED  13070                    /* initial random seed, in decimal */
#define ACONST 25214903917                             /* constant multiplier */
#define C 11                                             /* additive constant */
#define MASK 281474976710655                                      /* 2^{48}-1 */

static int N;                      /* problem size: number of values in number array */
static int64_t seed;                                 /* current random number seed */

static int64_t sorted[MAX_RNP];        /* original numbers sorted in decreasing order */
static int64_t sumall;                              /* sum of all original numbers */
static int64_t minmax;         /* largest subset sum in best solution found so far */

static int64_t ckkcalls;            /* number of calls to ckk for 2-way partitions */
static int64_t cga3calls;          /* number of calls to cga3 for 3-way partitions */
static int64_t cga4calls;          /* number of calls to cga4 for 4-way partitions */
static int64_t cga5calls;          /* number of calls to cga4 for 4-way partitions */
static int64_t nodes2;                          /* number of SS two-way partitions */
static int64_t nodes3;                           /* number of three-way partitions */
static int64_t nodes4;                            /* number of four-way partitions */
static int64_t nodes5;                            /* number of five-way partitions */

typedef struct element {           /* structure consists of a set and its sum */
  int64_t sum;
  int64_t set;
} SetArray;

SetArray tsets[MAXSETS];         /* temporary array of sets for merge sorting */
int64_t tsums[MAXSETS];        /* temporary array of sums for merge sorting */

int nextsum;              /* index of next empty position in subset sum array */

typedef struct heapelement{  /* heap of sums from a and b in increasing order */
  int x;                                         /* index of element in asums */
  int y;                                         /* index of element in bsums */
  int64_t sum;}                                      /* sum of the elements */
 Heap;

 static int64_t A[MAX_RNP];        /* global array of numbers to be partitioned by CKK */

/* global data structures used by TWOPART */

int64_t asums[MAXSETS];              /* subset sums from numbers in A array */
int64_t bsums[MAXSETS];              /* subset sums from numbers in B array */
int64_t csums[MAXSETS];              /* subset sums from numbers in C array */
int64_t dsums[MAXSETS];              /* subset sums from numbers in D array */
int nasums, nbsums, ncsums, ndsums; /* number of sums in each of above arrays */
Heap abheap[MAXSETS], cdheap[MAXSETS]; /*heap of subset sums from pairs of sums*/
int abheapsize, cdheapsize;                       /* size of respective heaps */
int64_t alpha;          /* best difference found for 2-way CKK partitioning */

/* global data structures used by CGA3, CGA4, and CGA5 */

int64_t e[MAX_RNP];                               /* numbers to be partitioned */
int64_t beta;                                        /* best solution found */
int N345;                    /* number of elements to be partitioned with CGA */

/* INIT initializes it's argument array with random numbers from zero to
   2^{MAX_RNPUM}-1.  It returns their sum. */

int64_t init (int64_t a[MAX_RNP], int n)

{int i;                                                   /* index into array */
 int64_t sum;                                         /* sum of all numbers */

 sum = 0;                                    /* initialize sum of all numbers */
 for (i = 0; i < n; i++)                         /* for each element of array */
   {seed = (ACONST * seed + C) & MASK;        /* next seed in random sequence */
     a[i] = seed;                       /* random value from zero to 2^{48}-1 */
     sum += a[i];}                              /* compute sum of all numbers */
 return (sum);}                                      /* return sum of numbers */

/* SORTLONGSDOWN takes an array of longs, and the length of the array,
   and sorts the array in decreasing order using insertion sort. */

void sortlongsdown (int64_t a[MAXK], int k)

{int i,j;                                   /* indices into array for sorting */
 int64_t temp;                              /* temporary value for swapping */

 for (i = 1; i < k; i++)
   {temp = a[i];
     for (j = i - 1; j >= 0; j--)
       if (a[j] < temp) a[j+1] = a[j];
       else break;
     a[j+1] = temp;}}

/* SORTLONGSUP takes an array of longs, and the length of the array,
   and sorts the array in increasing order using insertion sort. */

void sortlongsup (int64_t a[MAXK], int k)

{int i,j;                                   /* indices into array for sorting */
 int64_t temp;                              /* temporary value for swapping */

 for (i = 1; i < k; i++)
   {temp = a[i];
     for (j = i - 1; j >= 0; j--)
       if (a[j] > temp) a[j+1] = a[j];
       else break;
     a[j+1] = temp;}}

/* INSERT takes an array index FIRST, a new subset sum VECTOR, and an array A of
   vectors sorted in decreasing order of largest elements, and modifies array A
   by inserting the new vector in sorted order by largest element. */

void insert (int first, int n, int k, int64_t vector[MAXK], int64_t vects[MAX_RNP][MAXK])

{int i;                                  /* index into array of subpartitions */
 int j;                                        /* index to elements of vector */

 for (i = first; i < n-1; i++)         /* insert new partition in sorted list */
   if (vector[0] < vects[i+1][0])          /* haven't found correct place yet */
     for (j = 0; j < k; j++)                    /* for each element of vector */
       vects[i][j] = vects[i+1][j];     /* copy current partition up in order */
   else break;                              /* found correct place, exit loop */

 for (j = 0; j < k; j++)                        /* for each element of vector */
   vects[i][j] = vector[j];}              /* insert new subpartition in order */

/* KK takes an array A of integers, sorted in increasing order, its length N,
   the number of partitions K, and the sum of all the numbers, and returns the
   maximum subset sum in the KK approximation of the best K-way partition. */

int64_t kk (int64_t a[MAX_RNP], int n, int k, int64_t sum)

{int64_t vects[MAX_RNP][MAXK];           /* array of vectors N long and K wide */
 int64_t vector[MAXK];                  /* combination of first two vectors */
 int i, j;                                                 /* utility indices */
 int64_t max;                       /* absolute value of maximum subset sum */

 if (k >= n) return ((int64_t) a[n-1]); /*largest subset sum is largest number*/

 for (i = 0; i < n; i++)                   /* create initial array of vectors */
   {vects[i][0] = a[n-i-1];              /* copy to vects in decreasing order */
   for (j = 1; j < k; j++)
     vects[i][j] = 0;}

 for (i = 0; i < n-1; i++)
   {for (j = 0; j < k; j++)                            /* for each subset sum */
     vector[j] = vects[i][j] + vects[i+1][k-j-1];/* combine particular subsets*/
   sortlongsdown (vector, k);          /* sort the vector in decreasing order */
   for (j = 0; j < k; j++)                             /* for each subset sum */
     vector[j] = vector[j] - vector[k-1];     /* subtract smallest subset sum */
   insert (i+1, n, k, vector, vects);}   /* insert new vector in sorted order */

 for (j = 0; j < k; j++)       /* compute largest subset sum from differences */
   sum = sum - vector[j];                    /* subtract relative subset sums */
 max = (sum / k) + vector[0];                  /* absolute maximum subset sum */
 return (max);}

/* KK2 takes an array of numbers sorted in decreasing order, and finds the
   two-way KK partition from that array, returning its subset sum difference. It
   iteratively takes the first two numbers in the list, and replaces them with
   their difference, inserted in sorted order in the remaining list. */

int64_t kk2 (int64_t a[MAX_RNP],                        /* array of subset sum vectors */
             int n)                                    /* number of elements in array */

{int i;                                                   /* index to vectors */
 int j;                          /* index to individual subset sums in vector */
 int64_t newNumber;   /* newNumber number which is difference between first two numbers */

 for (i = 0; i < n-1; i++)                 /* combine largest vectors in turn */
   {newNumber = a[i] - a[i+1];           /* new number is difference of two largest */
   for (j = i+2; j < n ; j++)                    /* for each remaining number */
     if (newNumber >= a[j]) break;            /* found correct place for new number */
     else a[j-1] = a[j];   /* new number is smaller than next, move next back */
   a[j-1] = newNumber;}                     /* place new number in correct position */
 return (a[n-1]);}      /* one number left, its value is partition difference */

/* GENSETS takes an array of integers, an array of subsets to fill, the first
   index and last indices into the integer array, the sum of the numbers
   included so far, and the characteristic function of the elements included so
   far. It generates all subsets of the remaining numbers in the NUMbers array
   from index FIRST to index LAST, storing them in the SET array.  It places the
   numbers in consecutive locations indexed by the global variable NEXTSUM, leaving
   in NEXTSUM the number of sets generated. */

void gensets (int64_t num[MAX_RNP],
              SetArray set[MAXSETS],
              int first, int last,
              int64_t cursum, int64_t curset)

{if (first > last)                                        /* set is completed */
  {set[nextsum].sum = cursum;     /* store subset sum in array of subset sums */
  set[nextsum++].set = curset;}       /* store characteristic function of set */
 else                                                /* set not yet completed */
   {gensets (num, set, first+1, last, cursum, curset);     /* exclude next element */
   gensets (num, set, first+1, last, cursum + num[first], curset | ((int64_t) 1 << first));}}

/* SORTSETS sorts an array of subset sums, and the corresponding subsets
   themselves, in increasing order using mergesort.  It takes the indices of the
   FIRST and LAST elements to be sorted, and sorts those elements in increasing
   order.  It uses a temporary array to do the merge step.  */

void sortsets (SetArray sets[MAXSETS], int first, int last)

{int middle;                                      /* index to middle of array */
 int head1, head2; /* indices of current heads of sorted lists for merge step */
 int tail;                       /* index of next available position in tempa */
 SetArray temp;                 /* temporary pair of set amd sum for swapping */
 int i, j;                              /* utility indices for insertion sort */

 if (last - first <= 50)                      /* small number of sets to sort */
   {for (i = first+1; i <= last; i++)             /* from 2nd set to last set */
       {temp = sets[i];                            /* save set to be inserted */
         for (j = i - 1; j >= first; j--) /* find position for set in sorted order */
           if (sets[j].sum > temp.sum) sets[j+1] = sets[j]; /*move larger sets forward*/
           else break;                 /* found correct position for next set */
         sets[j+1] = temp;}                       /* insert into sorted order */
     return;}

 middle = (first + last) / 2;             /* compute middle point of subarray */
 sortsets (sets, first, middle);         /* recursively merge sort first half */
 sortsets (sets, middle+1, last);       /* recursively merge sort second half */

 head1 = first;                                         /* head of first list */
 head2 = middle+1;                                     /* head of second list */
 tail = first;               /* first empty position in sorted temporary list */

 while (head1 <= middle && head2 <= last)    /* neither of the lists is empty */
   if (sets[head1].sum <= sets[head2].sum)   /* head of first list is smaller */
     tsets[tail++] = sets[head1++]; /* grab smaller element and advance head1 */
   else
     tsets[tail++] = sets[head2++]; /* grab smaller element and advance head2 */

 if (head2 > last)                         /* second list was exhausted first */
   while (head1 <= middle)                   /* until first list is exhausted */
     tsets[tail++] = sets[head1++];        /* copy first list to end of merge */

 head1 = first;                        /* reset pointer to head of both lists */
 while (head1 < head2) {                            /* until end of second list */
   sets[head1] = tsets[head1]; head1++;
 }
 } /* copy merged list back into original array*/

/* SORTSUMS sorts an array of subset sums in increasing order using mergesort.
   It takes the indices of the FIRST and LAST elements to be sorted, and sorts
   those elements in increasing order.  It uses a temporary array to do the
   merge step.  */

void sortsums (int64_t sums[MAXSETS], int first, int last)

{int middle;                                      /* index to middle of array */
 int head1, head2; /* indices of current heads of sorted lists for merge step */
 int tail;                       /* index of next available position in tempa */
 int64_t temp;                /* temporary pair of set amd sum for swapping */
 int i, j;                              /* utility indices for insertion sort */

 if (last - first <= 50)                      /* small number of sums to sort */
   {for (i = first+1; i <= last; i++)             /* from 2nd sum to last sum */
       {temp = sums[i];                            /* save sum to be inserted */
         for (j = i - 1; j >= first; j--) /* find position for set in sorted order */
           if (sums[j] > temp) sums[j+1] = sums[j]; /*move larger sets forward*/
           else break;                 /* found correct position for next set */
         sums[j+1] = temp;}                       /* insert into sorted order */
     return;}

 middle = (first + last) / 2;             /* compute middle point of subarray */
 sortsums (sums, first, middle);         /* recursively merge sort first half */
 sortsums (sums, middle+1, last);       /* recursively merge sort second half */

 head1 = first;                                         /* head of first list */
 head2 = middle+1;                                     /* head of second list */
 tail = first;               /* first empty position in sorted temporary list */

 while (head1 <= middle && head2 <= last)    /* neither of the lists is empty */
   if (sums[head1] <= sums[head2])           /* head of first list is smaller */
     tsums[tail++] = sums[head1++]; /* grab smaller element and advance head1 */
   else
     tsums[tail++] = sums[head2++]; /* grab smaller element and advance head2 */

 if (head2 > last)                         /* second list was exhausted first */
   while (head1 <= middle)                   /* until first list is exhausted */
     tsums[tail++] = sums[head1++];        /* copy first list to end of merge */

 head1 = first;                        /* reset pointer to head of both lists */
 while (head1 < head2) {                           /* until end of second list */
   sums[head1] = tsums[head1];head1++;
 }
 } /* copy merged list back into original array*/

/* GENSUMS takes an array X of numbers, the index of the LAST number, and
   generates an array SUMS of all sums that can be achieved by adding together
   numbers from X.  Each number in X can only be used at most once.  To allow
   the recursion, additional arguments include an index NEXTX to the next
   element of the array, and the SUMSOFAR achieved down this path.  There is
   also a global pointer NEXTSUM to the next empty element of the SUMS array. At
   the end, it is equal to the number of sums created. */

void gensums (int64_t nums[MAX_RNP],                          /* array of original numbers */
         int64_t sums[MAXSETS],                                   /* array of sums */
         int nextx,                            /* pointer to next element of X array */
         int64_t sumsofar,             /* sum so far of elements in current subset */
         int last)                                 /* index of last element in array */

{if (nextx == last)                          /* reached last element of array */
   {sums[nextsum++] = sumsofar;                     /* don't add last element */
    sums[nextsum++] = sumsofar + nums[nextx];}        /* add last element to sum */
  else {gensums (nums, sums, nextx+1, sumsofar, last);     /* don't add last element */
    gensums (nums, sums, nextx+1, sumsofar + nums[nextx], last);}} /* add last element */

/* CKK takes an array of int64_t numbers A, its length N, and their TOTAL sum,
   and finds the best partition, leaving the resulting difference in the global
   variable ALPHA. It runs branch-and-bound, starting with the Karmarkar-Karp
   solution. At each point, the largest two remaining numbers are selected, and
   replaced with either their difference or their sum, representing assigning
   them to different sets or the same set, respectively. */

void ckk (int64_t a[MAX_RNP],                                        /* array of numbers */
          int n,                                         /* number of elements in array */
          int64_t total)                                        /* sum of all numbers */

{int64_t diff2;                          /* difference of largest 2 numbers */
 int64_t sum2;                                  /* sum of largest 2 numbers */
 int64_t difference;                             /* difference of partition */
 int64_t b[MAX_RNP];                   /* new copy of list for recursive calls */
 int64_t rest;                        /* sum of all elements except first 2 */
 int i;                                                   /* index into array */

 diff2 = a[0] - a[1];                   /* difference of two largest elements */
 for (i = 2; i < n; i++)          /* copy list and insert difference in order */
   if (diff2 < a[i])
     b[i-2] = a[i];                       /* new number is less, keep copying */
   else break;                              /* found correct place, exit loop */
 b[i-2] = diff2;                             /* insert new element into array */
 for (i; i < n; i++)                           /* copy remaining elements */
   b[i-1] = a[i];

 if (n == 5)                   /* when only 4 numbers are left, KK is optimal */
   {diff2 = b[0] - b[1];                  /* difference of 2 largest elements */
    if (diff2 < b[2]) difference = b[2] - b[3] - diff2;    /* b[2] is biggest */
    else difference = diff2 - b[2] - b[3];                /* diff2 is biggest */
    if (difference < 0) difference = -difference;      /* take absolute value */
    if (difference < alpha)            /* better than best previous partition */
      alpha = difference;}                     /* reset alpha to better value */

 else
   {rest = total - a[1] - a[1] - b[0];    /* sum of all elements except first */
    if (b[0] >= rest)                    /* if largest element >= sum of rest */
      {if (b[0] - rest < alpha)               /* best better than best so far */
        alpha = b[0] - rest;                   /* reset alpha to better value */
      return;}            /* if difference is larger than rest, so is the sum */
    ckk (b, n-1, total - a[1] - a[1]);         /* one less element, new total */
    if (alpha <= 1) return;}  /* difference of 0 or 1 is perfect, stop search */

 sum2 = a[0] + a[1];                            /* sum of largest two numbers */
 if (n == 5)                   /* when only 4 numbers are left, KK is optimal */
   {diff2 = sum2 - a[2];                  /* difference of 2 largest elements */
    if (diff2 < a[3]) difference = a[3] - a[4] - diff2;       /* a[3] biggest */
    else difference = diff2 - a[3] - a[4];                /* diff2 is biggest */
    if (difference < 0) difference = - difference;     /* take absolute value */
    if (difference < alpha)            /* better than best previous partition */
      alpha = difference;                      /* reset alpha to better value */
    return;}                                     /* stop searching and return */

 rest = total - a[0] - a[1];          /* sum of all elements except first two */
 if (sum2 >= rest)                       /* if largest element >= sum of rest */
      {if (sum2 - rest < alpha)               /* best better than best so far */
         alpha = sum2 - rest;                  /* reset alpha to better value */
      return;}            /* if difference is larger than rest, so is the sum */

 a[1] = sum2;                    /* sum of two largest is new largest element */
 ckk (a+1, n-1, total);          /* call on subarray with one less element */
 a[1] = sum2 - a[0];                       /* restore array to previous state */

 return;}

/* TWOPART takes an array of NUMberS, the Number of numbers in the
   array, and their SUM, and optimally partitions them two ways using
   the Schroeppel and Shamir algorithm.  It returns the larger subset
   sum in the optimal partition. */

int64_t twopart (int64_t nums[MAX_RNP], int n, int64_t sum)

{int i;                                                      /* utility index */
 int64_t best;                           /* best partition difference found */
 int64_t target1, target2;       /* two target values, equal if sum is even */
 int dpointer;                 /* index to largest number in dsums <= target2 */
 int nexty;           /* temporary for y component of next element of CD heap */
 int child, parent;              /* indices of parent and child nodes in heap */
 Heap next;                                     /* new element to add to heap */
 int64_t newsum;                         /* new subset sum being considered */
 int64_t compsum;                           /* subset sum of complement set */
 int64_t larger;                            /* larger of newsum and compsum */

 if (n < 12)               /* small number of elements, run CKK instead of SS */
   {alpha = MASK;                         /* initial value of best difference */
   ckkcalls++;                                /* count number of calls to ckk */
   for (i = 0; i < n; i++) /* */
     A[i] = nums[n-1-i]; /* copy numbers in decreasing order into global array*/
   if (n < 5) alpha = kk2 (A, n);    /* ckk only works with 5 or more numbers */
   else ckk (A, n, sum);   /* run CKK to find best 2-way partition difference */
   return ((sum + alpha) / 2);}  /* return larger subset of optimal partition */

 target1 = sum / 2;                                   /* smaller target value */
 target2 = sum - target1;                              /* larger target value */
 best = minmax;              /* only interested in solutions better than this */
 nodes2++;                           /* count number of SS two-way partitions */
 n = n - 1;                             /* exclude largest number from subset */

 nextsum = 0;                               /* initialize index to sums array */
 gensums(nums, asums, 0, 0ll, n/4-1);            /* generate sums of elements */
 nasums = nextsum;                                /* number of sums generated */
 sortsums (asums, 0, nasums-1);            /* merge sort array of sums from a */

 nextsum = 0;                               /* initialize index to sums array */
 gensums(nums, bsums, n/4, 0ll, n/2-1);          /* generate sums of elements */
 nbsums = nextsum;                                /* number of sums generated */
 sortsums (bsums, 0, nbsums-1);            /* merge sort array of sums from b */

 nextsum = 0;                               /* initialize index to sums array */
 gensums(nums, csums, n/2,  0ll, n*3/4-1);       /* generate sums of elements */
 ncsums = nextsum;                                /* number of sums generated */
 sortsums (csums, 0, ncsums-1);            /* merge sort array of sums from c */

 nextsum = 0;                               /* initialize index to sums array */
 gensums(nums, dsums, n*3/4, 0ll, n-1);          /* generate sums of elements */
 ndsums = nextsum;                                /* number of sums generated */
 sortsums (dsums, 0, ndsums-1);            /* merge sort array of sums from d */

 best = (sum + kk2(nums, n+1)) / 2;              /* larger set in KK solution */
 if (best == target2) return (best);                /* KK solution is optimal */

 for (i = 0; i < nasums; i++)                                 /* make ab heap */
   {abheap[i].x = i;                         /* aptr pointer is same as index */
    abheap[i].y = 0;              /* smallest value of bsums is first element */
    abheap[i].sum = asums[i];        /* asums[x] + bsums[0], but bsums[0] = 0 */
    if (abheap[i].sum >= best) break;}       /* sum too big, done making heap */
 abheapsize = i;                      /* number of elements in heap initially */
                /* make CD maxheap, only with elements <= larger target value */
 dpointer = ndsums - 1;                    /* index to largest value in dsums */
 cdheapsize = 0;                                   /* no elements in heap yet */
 for (i = 0; i < ncsums; i++)            /* process csums in increasing order */
   {if (csums[i] >= best) break;            /* no more entries to add to heap */
    else cdheapsize++;                /* index of next empty location in heap */
    next.x = i;                                          /* cpointer is index */
    while (csums[i] + dsums[dpointer] >= best) dpointer--;    /* sums too big */
    next.y = dpointer;                    /* largest value of dsums <= target */
    next.sum = csums[i] + dsums[dpointer];         /* sum of new heap element */
    child = cdheapsize-1;                       /* index of last node in heap */
    while (child > 0)                  /* bubble child up to correct location */
      {parent = (child - 1) / 2;          /* index in heap of parent of child */
       if (next.sum > cdheap[parent].sum)   /* new element is too low in heap */
         {cdheap[child] = cdheap[parent];                 /* move parent down */
          child = parent;}                        /* parent is new child node */
       else break;}             /* found correct location of new heap element */
    cdheap[child] = next;}                             /* insert it into heap */

 while (abheapsize > 0 && cdheapsize > 0)  /* there are still valid sums left */
   {newsum = abheap[0].sum + cdheap[0].sum; /* next ab number + next cd number*/
    compsum = sum - newsum;                   /* subset sum of complement set */
    if (compsum >= newsum) larger = compsum;    /*  complement has larger sum */
    else larger = newsum;                      /* original set has larger sum */
    if (larger < best)                               /* better solution found */
      {best = larger;                                   /* update best so far */
        if (larger == target2) return (larger);}   /* perfect partition found */
    if (newsum < target1)               /* construct next element for AB heap */
      {if (abheap[0].y + 1 < nbsums)            /* still more b pointers left */
          {next.x = abheap[0].x;                  /* x pointer stays the same */
           next.y = abheap[0].y + 1;          /* set to next larger b pointer */
           next.sum = asums[next.x] + bsums[next.y];} /*sum of new heap element*/
       else                                  /* remove this element from heap */
         {abheapsize--;                        /* heap has one fewer elements */
          next = abheap[abheapsize];} /*replace top with last element of heap */
                       /* percolate new top of heap down to its correct place */
        parent = 0;
        while (2 * parent + 1 < abheapsize)  /* still at least one child left */
          {if (2 * parent + 2 == abheapsize)       /* node only has one child */
              child = 2 * parent + 1;
           else if (abheap[2*parent+1].sum < abheap[2*parent+2].sum) child = 2*parent+1;
           else child = 2 * parent + 2;                 /* find smaller child */
           if (next.sum <= abheap[child].sum) break;           /* found place */
           else
             {abheap[parent] = abheap[child];    /* bubble child up to parent */
              parent = child;}}                    /* child is now new parent */
        abheap[parent] = next;}     /* insert next element in parent position */

    else                 /* sum is greater than target, remove top of cd heap */
      {nexty = cdheap[0].y-1;
       while (nexty >= 0 &&                      /* still sums in this column */
              csums[cdheap[0].x] + dsums[nexty] + abheap[0].sum >= best)
         nexty--;                               /* total sum is still too big */
       if (nexty >= 0)                     /* didn't run out of sums in colun */
         {next.y = nexty;             /* set y coordinate in new heap element */
          next.x = cdheap[0].x;                      /* x pointer is the same */
          next.sum = csums[next.x] + dsums[nexty];}    /* sum of heap element */
       else                                  /* remove this element from heap */
         {cdheapsize--;                         /* heap has one fewer element */
          next = cdheap[cdheapsize];}    /* make new top of heap last element */
                         /* sink new top of heap down to its correct position */
        parent = 0;
        while (2 * parent + 1 < cdheapsize)  /* still at least one child left */
          {if (2 * parent + 2 == cdheapsize)       /* node only has one child */
              child = 2 * parent + 1;
           else if (cdheap[2*parent+1].sum > cdheap[2*parent+2].sum) child = 2*parent+1;
           else child = 2 * parent + 2;                  /* find larger child */
           if (next.sum >= cdheap[child].sum) break;           /* found place */
           else
             {cdheap[parent] = cdheap[child];
              parent = child;}}                    /* child is now new parent */
        cdheap[parent] = next;}}    /* insert next element in parent position */
 return (best);}                              /* return best subset sum found */

/* CGA3 takes the index of the first unassigned number, the sums of the two
 largest subsets, minus the size of the smallest, and the sum of the remaining
 numbers, and finds the best partition for the remaining numbers, leaving the
 resulting difference in beta. */

void cga3  (int next, int64_t big, int64_t med, int64_t small)

{int64_t newNumber;                  /* new number created by adding two together */

 if (next == N345-1)                                       /* one number left */
   {newNumber = small + e[next];        /* place last number in smallest subset sum */
   if (newNumber < beta) {                               /* new best partition found */
     if (newNumber >= big) {
       beta = newNumber;                     /* new number is largest */
     } else {
       beta = big;                                 /* big is still largest */
     }
   }
   return;}                                /* solution is complete, backtrack */

 newNumber = small + e[next];     /* place next number in smallest subset sum first */
 if (newNumber < beta)
   {if (newNumber >= big)                              /* new number is now largest */
     cga3 (next+1, newNumber, big, med);         /* recursively search rest of tree */
   else if (newNumber >= med)               /* new number is between big and medium */
     cga3 (next+1, big, newNumber, med);         /* recursively search rest of tree */
   else                                    /* next number is biggest of three */
     cga3 (next+1, big, med, newNumber);         /* recursively search rest of tree */
   if (big >= beta) return;}          /* recursive call found better solution */

 if (med > 0)         /* if both small and med are zero, don't put it in both */
   {newNumber = med + e[next];                  /* put next number in medium subset */
   if (newNumber < beta)
     {if (newNumber >= big)              /* new element plus medium is still medium */
       cga3 (next+1, newNumber, big, small);     /* recursively search rest of tree */
     else                                        /* new subset is now largest */
       cga3 (next+1, big, newNumber, small);     /* recursively search rest of tree */
     if (big >= beta) return;}}       /* recursive call found better solution */

 if (big > 0)              /* if all three are zero, don't place in all three */
   {newNumber = big + e[next];                    /* put next number in largest set */
   if (newNumber < beta) cga3 (next+1, newNumber, med, small);}}   /* search rest of tree */

/* CGA4 takes the index of the first unassigned number, the sums of the two
 largest subsets, minus the size of the smallest, and the sum of the remaining
 numbers, and finds the best partition for the remaining numbers, leaving the
 resulting difference in alpha. */

void cga4 (int next, int64_t huge, int64_t big, int64_t med, int64_t small)

{int64_t newNumber;                  /* new number created by adding two together */

 if (next == N345-1)                                       /* one number left */
   {newNumber = small + e[next];      /* place next number in smallest subset first */
   if (newNumber < beta) {                               /* new best partition found */
     if (newNumber >= huge) {
       beta = newNumber;                    /* new number is largest */
     } else {
       beta = huge;                                /* big is still largest */
     }
   }
   return;}                                /* solution is complete, backtrack */

 newNumber = small + e[next]; /* place next number in set with smallest subset first*/
 if (newNumber < beta)
   {if (newNumber >= huge)                             /* new number is now largest */
     cga4 (next+1, newNumber, huge, big, med);   /* recursively search rest of tree */
   else if (newNumber >= big)               /* new number is between big and medium */
     cga4 (next+1, huge, newNumber, big, med);   /* recursively search rest of tree */
   else if (newNumber >= med)               /* new number is between big and medium */
     cga4 (next+1, huge, big, newNumber, med);   /* recursively search rest of tree */
   else                                    /* next number is biggest of three */
     cga4 (next+1, huge, big, med, newNumber);   /* recursively search rest of tree */
   if (huge >= beta) return;}         /* recursive call found better solution */

 if (med > 0)         /* if both small and med are zero, don't put it in both */
   {newNumber = med + e[next];                  /* put next number in medium subset */
   if (newNumber < beta)
     {if (newNumber >= huge)             /* new element plus medium is still medium */
       cga4 (next+1, newNumber, huge, big, small);           /* search rest of tree */
     else if (newNumber >= big)          /* new element plus medium is still medium */
       cga4 (next+1, huge, newNumber, big, small);           /* search rest of tree */
     else cga4 (next+1, huge, big, newNumber, small);        /* search rest of tree */
     if (huge >= beta) return;}}      /* recursive call found better solution */

 if (big > 0)              /* if all three are zero, don't place in all three */
   {newNumber = big + e[next];                    /* put next number in largest set */
   if (newNumber < beta)
     {if (newNumber > huge)                               /* new element is largest */
       cga4 (next+1, newNumber, huge, med, small);           /* search rest of tree */
     else cga4 (next+1, huge, newNumber, med, small);        /* search rest of tree */
     if (huge >= beta) return;}}      /* recursive call found better solution */

 if (huge > 0)
   {newNumber = huge + e[next];                   /* put next number in largest set */
   if (newNumber < beta)
     cga4 (next+1, newNumber, big, med, small);}} /*recursively search rest of tree */

/* CGA5 takes the index of the first unassigned number, the sums of the five
 largest subsets so far, and finds the best partition for the remaining numbers,
 leaving the resulting difference in beta. */

void cga5 (int next, int64_t huge, int64_t big, int64_t med, int64_t small, int64_t tiny)

{int64_t newHeap;                  /* new number created by adding two together */

 if (next == N345 - 1)                                     /* one number left */
   {newHeap = tiny + e[next];       /* place next number in smallest subset first */
   if (newHeap < beta) {                                /* new best partition found */
     if (newHeap >= huge) {
       beta = newHeap;                    /* new number is largest */
     } else {
       beta = huge;                                /* big is still largest */
     }
   }
   return;}                                /* solution is complete, backtrack */

 newHeap = tiny + e[next]; /* place next number in set with smallest subset first */
 if (newHeap < beta)
   {if (newHeap >= huge)                             /* new number is now largest */
     cga5 (next+1, newHeap, huge, big, med, small);        /* search rest of tree */
   else if (newHeap >= big)               /* new number is between big and medium */
     cga5 (next+1, huge, newHeap, big, med, small);        /* search rest of tree */
   else if (newHeap >= med)               /* new number is between big and medium */
     cga5 (next+1, huge, big, newHeap, med, small);        /* search rest of tree */
   else if (newHeap >= small)                  /* next number is biggest of three */
     cga5 (next+1, huge, big, med, newHeap, small);        /* search rest of tree */
   else cga5 (next+1, huge, big, med, small, newHeap);     /* search rest of tree */
   if (huge >= beta) return;}         /* recursive call found better solution */

 if (small > 0)       /* if both small and med are zero, don't put it in both */
   {newHeap = small + e[next];                /* put next number in medium subset */
   if (newHeap < beta)
     {if (newHeap >= huge)             /* new element plus medium is still medium */
       cga5 (next+1, newHeap, huge, big, med, tiny);       /* search rest of tree */
     else if (newHeap >= big)          /* new element plus medium is still medium */
       cga5 (next+1, huge, newHeap, big, med, tiny);       /* search rest of tree */
     else if (newHeap >= med)
       cga5 (next+1, huge, big, newHeap, med, tiny);       /* search rest of tree */
     else cga5 (next+1, huge, big, med, newHeap, tiny);    /* search rest of tree */
     if (huge >= beta) return;}}      /* recursive call found better solution */

 if (med > 0)              /* if all three are zero, don't place in all three */
   {newHeap = med + e[next];                    /* put next number in largest set */
   if (newHeap < beta)
     {if (newHeap >= huge)                              /* new element is largest */
       cga5 (next+1, newHeap, huge, big, small, tiny);     /* search rest of tree */
     else if (newHeap >= big)
       cga5 (next+1, huge, newHeap, big, small, tiny);     /* search rest of tree */
     else cga5 (next+1, huge, big, newHeap, small, tiny);  /* search rest of tree */
     if (huge >= beta) return;}}      /* recursive call found better solution */

 if (big > 0)
   {newHeap = big + e[next];                    /* put next number in largest set */
   if (newHeap < beta)
     {if (newHeap >= huge)
       cga5 (next+1, newHeap, huge, med, small, tiny);     /* search rest of tree */
     else cga5 (next+1, huge, newHeap, med, small, tiny);  /* search rest of tree */
     if (huge >= beta) return;}}      /* recursive call found better solution */

 if (huge > 0)
   {newHeap = huge + e[next];
   if (newHeap < beta)
     cga5 (next+1, newHeap, big, med, small, tiny);}}

/* PART takes an array NUM of integers sorted in increasing order, the length N
   of the vector, the sum of all the numbers, and a number K of subsets to
   partition it into.  It computes the optimal k-way partition of the numbers if
   all subset sums are less than MINMAX, returning either this value, or MINMAX
   if no better solution was found.  If the last argument, TOP, is equal to one,
   then this function is allowed to reset MINMAX if a better solution is
   found. */
/* PART takes an array NUM of integers sorted in increasing order, the length N
   of the vector, the sum of all the numbers, and a number K of subsets to
   partition it into.  It computes the optimal k-way partition of the numbers if
   all subset sums are less than MINMAX, returning either this value, or MINMAX
   if no better solution was found.  If the last argument, TOP, is equal to one,
   then this function is allowed to reset MINMAX if a better solution is
   found. */

int64_t part (int64_t num[MAXN], int n, int64_t sum, int k, int top)

{int64_t lower;                       /* lower bound of top-level subset sum */
  int64_t upper;                      /* upper bound of top-level subset sum */
  int64_t perfect;                /* maximum subset sum in perfect partition */

  SetArray a[MAXSETS];    /* array of large sets from first quarter of numbers */
  SetArray b[MAXSETS];   /* array of large sets from second quarter of numbers */
  SetArray c[MAXSETS];    /* array of large sets from third quarter of numbers */
  SetArray d[MAXSETS];    /* array of large sets from third quarter of numbers */
  int nasets, nbsets, ncsets, ndsets;          /* number of sets in each array */

  Heap abheap[MAXSETS];       /* heap of sets from combination of A and B sets */
  Heap cdheap[MAXSETS];       /* heap of sets from combination of C and D sets */
  int abheapsize, cdheapsize;               /* number of elements in each heap */
  int dpointer; /* pointer to current element in d array, when building CD heap*/
  Heap cdlist[MAXLIST];           /* list of sets already removed from CD heap */
  int cdlistsize;             /* number of subsets in list popped from CD Heap */
  Heap newHeap;                                /* new element being added to heap */

  int64_t x[MAXN], y[MAXN];   /* arrays to contain first subset and its complement */
  int nx, ny;                     /* number of numbers in each of these arrays */
  int first;                                /* index of first subset in cdlist */
  int next;                         /* index of first empty location in cdlist */
  int64_t topsum;        /* sum of combination subset from top of both heaps */
  int index;                                              /* index into cdlist */
  int64_t sol1, sol2; /*maximum subset sums from subpartitions of two subsets*/
  int64_t newsol;                                /* maximum of sol1 and sol2 */
  int64_t set;           /* characteristic function of set being constructed */
  int64_t subsum;                              /* subset sum of first subset */
  int k1, k2; /*number of subsets to partition first subset and complement into*/
  int parent, child;              /* indices of parent and child nodes in heap */
  int i;                                                      /* utility index */
  int64_t best;      /* largest subset sum in best partition of argument set */
  int nexty;           /* temporary for y component of next element of CD heap */

  if (n <= k) return num[n-1]; /* no more numbers than subsets, return largest */

  if (k == 3 && n < 11)             /* special case small three-way partitions */
    {beta = minmax;   /* initial upper bound is max sum in best solution so far*/
      cga3calls++;                            /* count number of calls to cga3 */
      for (i = 1; i < n; i++)            /* largest number is never referenced */
        e[i] = num[n-1-i]; /*copy numbers in decreasing order into global array*/
      N345 = n;  /* global number of elements to be partitioned for efficiency */
      cga3 (1, num[n-1], 0ll, 0ll); /* find solution with complete greedy algorithm*/
      return (beta);}          /* return largest subset in best solution found */

  if (k == 4 && n < 13)              /* special case small four-way partitions */
    {beta = minmax;      /* initial upper bound is max of best solution so far */
      cga4calls++;                            /* count number of calls to cga4 */
      for (i = 1; i < n; i++)            /* largest number is never referenced */
        e[i] = num[n-1-i]; /*copy numbers in decreasing order into global array*/
      N345 = n;  /* global number of elements to be partitioned for efficiency */
      cga4 (1, num[n-1], 0ll, 0ll, 0ll); /* find solution with complete greedy algorithm*/
      return (beta);}          /* return largest subset in best solution found */

  if (k == 5 && n < 16)              /* special case small five-way partitions */
    {beta = minmax;      /* initial upper bound is max of best solution so far */
      cga5calls++;                            /* count number of calls to cga5 */
      for (i = 1; i < n; i++)            /* largest number is never referenced */
        e[i] = num[n-1-i];  /* copy them in decreasing order into global array */
      N345 = n;  /* global number of elements to be partitioned for efficiency */
      cga5(1, num[n-1], 0ll, 0ll, 0ll, 0ll);       /* use CGA to find solution */
      return (beta);}          /* return largest subset in best solution found */

  best = kk (num, n, k, sum);     /* Karmarkar-Karp solution is initial approx */

  if (n <= k + 2) return (best);         /* kk is always optimal if k <= n + 2 */
  if (sum % k == 0) perfect = sum / k;                /* largest subset sum of */
  else perfect = sum / k + 1;                             /* perfect partition */
  if (num[n-1] > perfect) perfect = num[n-1];     /* can't be < largest number */
  if (best == perfect) return (best);      /* kk solution is perfect partition */
  if (top == 1) minmax = best;   /* top-level call, set global bound to KK sol */

  if (k == 3) nodes3++;                /* count number of three-way partitions */
  else if (k == 4) nodes4++;            /* count number of four-way partitions */
  else if (k == 5) nodes5++;            /* count number of four-way partitions */

  k1 = k / 2;       /* number of subsets first subset will be partitioned into */
  k2 = k - k1; /* number of subsets remaining elements will be partitioned into*/
  if (best > minmax) best = minmax; /* don't search for solutions worse than minmax */
  upper = k2 * (best - 1);                  /* upper bound on first subset sum */
  lower = sum - k1 * (best - 1);            /* lower bound on first subset sum */
  n = n - k1;                 /* exclude K1 largest numbers from consideration */


  nextsum = 0;                    /* starting index to place sets in set array */
  gensets (num, a, 0, n/4-1, 0, 0);  /* combinations of 1st quarter of numbers */
  nasets = nextsum;                             /* number of subsets generated */
  sortsets (a, 0, nextsum - 1); /* sort subsets in increasing subset sum order */

  nextsum = 0;                    /* starting index to place sets in set array */
  gensets (num, b, n/4, n/2-1, 0, 0); /*combinations of 2nd quarter of numbers */
  nbsets = nextsum;                             /* number of subsets generated */
  sortsets (b, 0, nextsum - 1); /* sort subsets in increasing subset sum order */

  nextsum = 0;                    /* starting index to place sets in set array */
  gensets (num, c, n/2, n*3/4-1, 0, 0);/*combinations of 3rd quarter of numbers*/
  ncsets = nextsum;                             /* number of subsets generated */
  sortsets (c, 0, nextsum - 1); /* sort subsets in increasing subset sum order */

  nextsum = 0;                    /* starting index to place sets in set array */
  gensets (num, d, n*3/4, n-1, 0, 0); /*combinations of 4th quarter of numbers */
  ndsets = nextsum;                             /* number of subsets generated */
  sortsets (d, 0, nextsum - 1); /* sort subsets in increasing subset sum order */

  /*construct min heap of initial combinations of sets from array A and array B*/
  for (index = 0; index < nasets; index++)          /* for each set in A array */
    {abheap[index].x = index;                 /* aptr pointer is same as index */
      abheap[index].y = 0;         /* smallest value of bsums is first element */
      abheap[index].sum = a[index].sum; /*a[index].sum + b[0].sum, b[0].sum = 0*/
      if (abheap[index].sum > upper) break;}  /* sum too big, done making heap */
  abheapsize = index;                          /* number of elements in abheap */

  /*construct max heap of initial combinations of sets from array C and array D*/
  dpointer = ndsets - 1;                    /* index to largest value in dsums */
  cdheapsize = 0;                                   /* no elements in heap yet */
  for (index = 0; index < ncsets; index++) /*process csums in increasing order */
    {if (c[index].sum > upper) break;        /* no more entries to add to heap */
      else cdheapsize++;               /* index of next empty location in heap */
      newHeap.x = index;                                     /* C pointer is index */
      while (c[index].sum + d[dpointer].sum > upper) dpointer--; /* find sums <= upper */
      newHeap.y = dpointer;                    /* largest value of dsums <= target */
      newHeap.sum = c[index].sum + d[dpointer].sum;         /* sum of heap element */
      child = cdheapsize-1;                     /* index in heap of child node */
      while (child > 0)                 /* bubble child up to correct location */
        {parent = (child - 1) / 2;         /* index in heap of parent of child */
          if (newHeap.sum > cdheap[parent].sum)        /* child is too low in heap */
            {cdheap[child] = cdheap[parent];
              child = parent;}                     /* parent is new child node */
          else break;}  /* child is in correct place, add next element to heap */
      cdheap[child] = newHeap;}                             /* insert it into heap */

  first = 0;                                         /* no entries in list yet */
  next = 0;                                    /* first empty location in list */
  cdlistsize = 0;                     /* list of cd subsets is initially empty */


  while (abheapsize > 0)                             /* until AB heap is empty */
    /* first remove sets with sums above upper bound from list */
    {while (cdlistsize > 0 && abheap[0].sum + cdlist[first].sum > upper)
        {first = (first + 1) % MAXLIST;             /* remove subset from list */
          cdlistsize--;}                                /* reduce size of list */

      /* add new sets to list with sums within bounds */
      topsum = cdheap[0].sum + abheap[0].sum; /*sum of elements on top of heaps*/
      while (cdheapsize > 0 && topsum >= lower)       /* new set within bounds */
        {

        if (topsum <= upper)                         /* new set within bounds */
            {cdlist[next] = cdheap[0];             /* add heap element to list */
              next = (next + 1) % MAXLIST;     /* add new set to end of ablist */
              cdlistsize++;
              if (cdlistsize > MAXLIST)
                {printf ("error: subset list size exceeded\n"); exit(0);}}

          nexty = cdheap[0].y-1;                     /* next element in column */
          while (nexty >= 0 &&                    /* still sums in this column */
              c[cdheap[0].x].sum + d[nexty].sum + abheap[0].sum > upper)
            nexty--;                             /* total sum is still too big */
          if (nexty >= 0)                   /* didn't run out of sums in colun */
            {newHeap.y = nexty;            /* set y coordinate in new heap element */
             newHeap.x = cdheap[0].x;                     /* x pointer is the same */
             newHeap.sum = c[newHeap.x].sum + d[nexty].sum;}    /* sum of heap element */
          else                              /* no more elements in this column */
            {cdheapsize--;                      /* size of heap shrinks by one */
              if (cdheapsize > 0)                   /* CDheap is not yet empty */
                newHeap = cdheap[cdheapsize];/*replace top of heap with last member*/
              else break;}         /* CDheap is empty, break out of while loop */
                     /* percolate new top of heap down to its correct position */
          parent = 0;                    /* initially parent node is root node */
          while (2 * parent + 1 < cdheapsize) /* still at least one child left */
            {if (2 * parent + 2 == cdheapsize) /* node has only one child left */
                child = 2 * parent + 1;
              else if (cdheap[2*parent+1].sum >= cdheap[2*parent+2].sum)
                child = 2 * parent + 1;               /* left child is smaller */
              else child = 2 * parent + 2;           /* right child is smaller */
              if (newHeap.sum >= cdheap[child].sum) break; /*found place*/
              else
                {cdheap[parent] = cdheap[child];
                  parent = child;}}                 /* child is now new parent */
                 cdheap[parent] = newHeap; /*insert next element in parent position*/
          topsum = cdheap[0].sum + abheap[0].sum;}  /* sum of two top elements of heaps */

      if (cdlistsize > 0)/*any subsets left in the list between lower and upper*/
        {index = first;                                /* first subset in list */
          while (index != next)        /* there are still more subsets on list */
            {subsum = cdlist[index].sum + abheap[0].sum;   /* first subset sum */
              if (subsum >= lower && subsum <= upper)/*subset sum within bounds*/
                {set = c[cdlist[index].x].set |
                       d[cdlist[index].y].set |
                       a[abheap[0].x].set |
                       b[abheap[0].y].set;
                  if (k == 3)                   /* partitioning set three ways */
                    {ny = 0;      /* constuct array of numbers in first subset */
                      for (i = 0; i < n; i++)
                        {if ((set & 1) == 1)     /* number is in larger subset */
                            {y[ny] = num[i];       /* add element to first set */
                              ny++;}        /* count numbers in complement set */
                          set = set >> 1;} /* shift to get bit for next element*/
                      sol2 = twopart (y, ny, subsum);  /* larger of 2-way part */
                      if (sol2 <= sum - subsum)/*complement set has larger sum */
                        newsol = sum - subsum;     /* largest of 3 subset sums */
                      else newsol = sol2;      /* largest of three subset sums */
                      if (newsol < best)    /* better than best local solution */
                        {best = newsol;          /* update best local solution */
                          upper = k2 * (best - 1);          /* new upper bound */
                          lower = sum - k1 * (best - 1);    /* new lower bound */
                          if (top == 1) minmax = best; /*better global solution*/
                          if (lower > upper || best == perfect) return (best);}}

                  else                    /* partitioning more than three ways */
                    {ny = nx = 0;   /* constuct arrays of numbers in both sets */
                      for (i = 0; i < n; i++)
                        {if ((set & 1) == 1)      /* number is in first subset */
                            {y[ny] = num[i];    /* add element to original set */
                              ny++;}          /* count numbers in original set */
                          else
                            {x[nx] = num[i];  /* add element to complement set */
                              nx++;}        /* count numbers in complement set */
                          set = set >> 1;} /* shift to get bit for next element*/

                      for (i = 0; i < k1; i++) /* add K1 largest to complement set */
                        x[nx + i] = num[n + i];
                      nx += k1;

                      if (x[nx-1] < minmax && y[ny-1] < minmax) {/*largest members<minmax*/
                      if (ny < nx)                  /* fewer numbers in y set */
                        {if (k2 == 2) sol2 = twopart (y, ny, subsum);
                          else sol2 = part (y, ny, subsum, k2, 0);
                          if (sol2 < minmax) /* could lead to better partition */
                            {if (k1 == 2) sol1 = twopart (x, nx, sum - subsum);
                              else sol1 = part (x, nx, sum - subsum, k1, 0);
                              if (sol1 <= sol2) newsol = sol2; /* find larger subset sum */
                              else newsol = sol1; /* largest subset sum of 2 solutions */
                              if (newsol < best)  /* better than best local solution */
                                {best = newsol;  /* update best local solution */
                                  upper = k2 * (best - 1); /* new upper bound */
                                  lower = sum - k1 * (best - 1); /* new lower bound */
                                  if (top == 1) minmax = best;/*better global solution*/
                                  if (lower > upper || best == perfect) return (best);}}}

                      else    /* x has more elements than y, partition y k2 ways first */
                        {if (k1 == 2) sol1 = twopart (x, nx, sum - subsum);
                          else sol1 = part (x, nx, sum - subsum, k1, 0);
                          if (sol1 < minmax)   /* could lead to better partition */
                            {if (k2 == 2) sol2 = twopart (y, ny, subsum);
                              else sol2 = part (y, ny, subsum, k2, 0);
                              if (sol1 <= sol2) newsol = sol2; /*find larger subset sum */
                              else newsol = sol1;    /* find larger subset sum */
                              if (newsol < best) /* better than best local solution */
                                {best = newsol;    /* update best local solution */
                                  upper = k2 * (best - 1);       /* new upper bound */
                                  lower = sum - k1 * (best - 1); /* new lower bound */
                                  if (top == 1) minmax = best;/*better global solution*/
                                  if (lower > upper || best == perfect) return (best);}}}}}}

              index = (index + 1) % MAXLIST;}}                /* next subset on CDlist */

      if (abheap[0].y < nbsets - 1)         /* there is another element in this column */
        {newHeap.x = abheap[0].x;          /* replace with next combination in this column */
          newHeap.y = abheap[0].y + 1;
          newHeap.sum = a[newHeap.x].sum + b[newHeap.y].sum;} /* sum of new subset */
      else
        {abheapsize--;                           /* decrease size of heap by one */
          if (abheapsize > 0)                           /* ABheap is not yet empty */
            newHeap = abheap[abheapsize];     /* replace top of heap with last member */
          else break;}                                          /* cdheap is empty */
                    /* percolate new top of heap down to its correct position */
      parent = 0;                          /* initially parent node is root node */
      while (2 * parent + 1 < abheapsize)       /* still at least one child left */
        {if (2 * parent + 2 == abheapsize)       /* node has only one child left */
            child = 2 * parent + 1;
          else if (abheap[2*parent+1].sum <= abheap[2*parent+2].sum) /* compare children */
            child = 2 * parent + 1;                        /* left child is larger */
          else child = 2 * parent + 2;                    /* right child is larger */
          if (newHeap.sum <= abheap[child].sum) break; /* found right place */
          else
            {abheap[parent] = abheap[child];
              parent = child;}}                          /* child is now new parent */
      abheap[parent] = newHeap;}      /* insert next element in parent position */

  return (best);}



/* This is the main function.  It calls init to generate the random numbers,
 then sorts them in decreasing order.  Next it calls KK5 to generate an
 approximate 5-way partition.  If there are more that 7 numbers, or KK5
 doesn't return an optimal partition, then it calls five-way to optimally
 partition the numbers. */

int64_t executeRNP(const PartitioningProblem &problem, BinPackingStats &stats) {

  const int &K = problem.K;
  if (K > MAXK) {
    printf("K out of range, MAXK=%d\n", MAXK);
    exit(0);
  }
  N = problem.N;

  memcpy(sorted, problem.S, N * sizeof(int64_t));
  sumall = problem.sum;

  sortlongsup(sorted, N); /* sort numbers in increasing order */

  minmax = sumall; /* initialize best solution to ridiculously large value */

  if (K == 2) {
    cout.flush();
    minmax = twopart(sorted, N, sumall / 2); /*optimal 2-way partition*/
  } else {

    minmax = part(sorted, N, sumall, K, 1); /* optimally partition K ways*/
  }

  //printf("%ld\n",minmax);
  return minmax;
  //printf ("%3d %12ld\n", trial, minmax);

}

/* This is the main function.  It calls init to generate the random numbers,
   then sorts them in decreasing order.  Next it calls KK5 to generate an
   approximate 5-way partition.  If there are more that 7 numbers, or KK5
   doesn't return an optimal partition, then it calls five-way to optimally
   partition the numbers. */
//
//int main (int argc, char *argv[])
//
//{int64_t totalmax;              /* total of all 5-way partition differences */
// int64_t totalckk, total2, totalcga3, total3, totalcga4, total4, totalcga5, total5;
// int i;                                                      /* utility index */
// int trial;                                        /* number of current trial */
// int64_t perfect;                /* largest subset sum in perfect partition */
// int trialnum;                                /* trial number read from input */
// int numperfect;                        /* number of perfect partitions found */
//
//
// sscanf(argv[1], "%d", &K);       /* read number of subsets from command line */
// sscanf(argv[2], "%d", &N);        /* read number of values from command line */
// sscanf(argv[3], "%d", &TRIALS);   /* read number of values from command line */
//
// seed = INITSEED;               /* initialize seed of random number generator */
// totalmax = totalckk = total2 = totalcga3 = total3 = totalcga4 = total4 = totalcga5 = total5 = numperfect = 0;
//
// for (trial = 1; trial <= TRIALS; trial++)      /* for each independent trial */
//   {sumall = init (sorted, N);    /* generate random values, return their sum */
//
//   sortlongsup (sorted, N);               /* sort numbers in increasing order */
//
//   if (sumall % K == 0) perfect = sumall / K;
//   else perfect = sumall / K + 1;
//
//   minmax = sumall;   /* initialize best solution to ridiculously large value */
//
//   ckkcalls = nodes2 = cga3calls = nodes3 = cga4calls = nodes4 = cga5calls = nodes5 = 0;
//
//   if (K == 2) minmax = twopart (sorted, N, sumall); /*optimal 2-way partition*/
//   else minmax = part (sorted, N, sumall, K, 1); /* optimally partition K ways*/
//
//   if (minmax == perfect) numperfect++;   /* count number of perfect partitions */
//
//   totalmax += minmax;
//   totalckk += ckkcalls;
//   total2 += nodes2;
//   totalcga3 += cga3calls;
//   total3 += nodes3;
//   totalcga4 += cga4calls;
//   total4 += nodes4;
//   totalcga5 += cga5calls;
//   total5 += nodes5;
//
//   }
// printf("%d %2d %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %d\n",
//        K,N,totalmax,totalckk,total2,totalckk+total2,totalcga3,total3,totalcga4,total4,totalcga5,total5, numperfect);}
