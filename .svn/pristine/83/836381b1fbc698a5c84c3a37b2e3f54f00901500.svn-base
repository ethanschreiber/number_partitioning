// This program takes a random set of N 48-bit integers, and lower and
//   upper bounds on subset sums, and generates all possible sums within
//   the bounds of subsets of the given numbers.  It is an extension of
//   the Schroeppel and Shamir algorithm.

#include "SubsetSum.hpp"
#include <stdio.h>                                    // standard I/O library
#include <stdint.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>


#include <iostream>

using std::cout;

using std::endl;

namespace ss {


// GENSUMS takes an array NUMS of numbers, the index of the LAST
//     number, and generates an array SUMS of all sums that can be
//     achieved by adding together numbers from NUMS.  Each number in NUMS
//     can only be used at most once.  To allow the recursion, additional
//     arguments include an index NEXT to the next element of the NUMS
//     array, and the SUMSOFAR achieved down this path.  There is also a
//     global pointer NEXTSUM to the next empty element of the SUMS
//     array. At the end, it is equal to the number of sums created.

void generateAllSums (const uint64_t nums[MAXN],             // array of original numbers
              vector<uint64_t> &sums,                // array of sums
              int next,                             // pointer to next element of NUMS array
              uint64_t sumsofar,                     // sum so far of elements in current subset
              int last) {                           // index of last element in array

  if (next == last) {                               // reached last element of array
    sums.push_back(sumsofar);                   // don't add last element
    sums.push_back(sumsofar + nums[next]);      // add last element to sum
  } else {
    generateAllSums (nums, sums, next+1, sumsofar, last);   // don't add last element
    generateAllSums (nums, sums, next+1, sumsofar + nums[next], last); // add last element
  }
}


/*
   GENSETS takes an array of integers, an array of subsets to fill, the first
   index and last indices into the integer array, the sum of the numbers
   included so far, and the characteristic function of the elements included so
   far. It generates all subsets of the remaining numbers in the NUMbers array
   from index FIRST to index LAST, storing them in the SET array.  It places the
   numbers in consecutive locations indexed by the global variable NEXTSUM, leaving
   in NEXTSUM the number of sets generated. */

void generateAllSets (const uint64_t S[MAXN],
                      vector<SSSetNode> &sets,
                      int first, int last,
                      uint64_t cursum, const DynamicBitset &curSet)

{
  if (first > last) {                                    // set is completed
    sets.push_back(SSSetNode(cursum,curSet));
  } else {                                               // set not yet completed
    generateAllSets (S, sets, first+1, last, cursum, curSet);  // exclude next element
    DynamicBitset newSet(curSet);       // Can try changing this so curset is not const and
    newSet[first] = true;    // can modify curset by uncommenting the two lines below
    //curSet[first] = true; // and then passing curset as opposed to curSet | orSet
    generateAllSets (S, sets, first+1, last, cursum + S[first], newSet);
    //curSet[first] = false;
  }
}
// Helper function, provides missing variables
// also sorts sets before returning
void generateAllSets(const uint64_t S[MAXN],
             vector<SSSetNode> &sets,
             int first, int last,
             bool sortAscending) {
  DynamicBitset curSet(MAXN);                                   // Instead of MAXN, this should be N
  generateAllSets(S,sets,first,last,0ll,curSet);
  if (sortAscending) {
    std::sort( sets.begin(), sets.end() ,std::less<SSSetNode>());  // Sort in ascending order
  } else {
    std::sort( sets.begin(), sets.end() ,std::greater<SSSetNode>());  // Sort in descending order
  }

}







} // end namespace
