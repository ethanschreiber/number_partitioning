/*
 * Moffitt.cpp
 *
 *  Created on: Jul 31, 2013
 *      Author: ethan
 */


#include "Moffitt.hpp"
#include "MoffittIE.hpp"
#include "MoffittSS.hpp"
#include "MoffittCachedIE.hpp"
#include "../ss/CGA.hpp"


#include <iomanip>
#include <algorithm> // for copy
#include <iterator> // for ostream_iterator
#include <sstream>

namespace moffitt {

uint64_t search(const int K,
                const vector<uint64_t> &S, const uint64_t SSum,
                const uint64_t CBest, uint64_t maxSoFar) {

  uint64_t currentValue;
  if (K==1) {                           // If we have reached the last bin
    currentValue = SSum;         // All elements must go in it
  } else if (S.empty()) {        // If there are no elements left
    currentValue = 0;                   // Then all remaining bins are empty
  } else {

    uint64_t CMin = SSum - (K-1) * (CBest-1);

// TEST HERE
//    MoffittCachedIE test(S,CMin,CBest-1);
//    cout << "Exiting" << endl;
//    exit(0);

    if (CMin < CBest) {



      // --- Begin IE ---
      vector<uint64_t> excluded;
      vector<uint64_t> included;
      currentValue = inclusionExclusion(K, 1, CMin, CBest, maxSoFar, S, SSum-S[0],
                                        included, S[0], excluded, 0);
      // --- End IE ---

      // --- Begin Schroeppel Shamir ---
      //currentValue = schroeppelShamir(K, CMin, CBest, maxSoFar, S, SSum);
      // --- End Schroeppel Shamir ---
    } else {
      currentValue = CBest;
    }
  }

  //cout << spaces(K) << "Returning: " << currentValue << endl << endl;

  return currentValue;
}

uint64_t executeMoffitt(const PartitioningProblem &problem, BinPackingStats &stats) {
  std::cout.imbue(std::locale("")); // For printing 1,000 instead of 1000

  {
     for (int i=0;i<MAX_K;i++) {
      tmpIECount[i] = 0;
      tmpIESearchCount[i] = 0;
    }
  }


  // Original maxSoFar is the minimum possible sum of a bin
  // We can assume all subsequent bins will be least this large
  uint64_t maxSoFar = divCeiling(problem.sum, (uint64_t) problem.K);  // Best we can do is divide evenly

  // Find upper bound
  const int NUM_NODES = 1000000;
  const int MAX_DISCREPENCIES = 5;
  uint64_t CBest = executeCGA(problem, NUM_NODES,MAX_DISCREPENCIES);
  //uint64_t CBest = problem.sum;
  //cout << "Upper Bound: " << CBest << endl;

  //cout << endl << "Sum: " << problem.sum << endl << endl;
  uint64_t answer = search(problem.K,vector<uint64_t>(problem.S,problem.S+problem.N),problem.sum,CBest,maxSoFar);



  return answer;
}




} // End Namespace
















//
//// Sets excludedElements and returns the sum of those elements.
//// This takes S, all of the remaining elements, and puts all elements
//// not in currentSet into excludedElements
//uint64_t setExcludedElements(vector<uint64_t> &excludedElements,
//                             const vector<uint64_t> &S,
//                             const SetNode &currentSet) {
//  uint64_t excludedElementsSum = 0;
//
//  int setIdx = 0;
//  for (size_t i=1; i< S.size();i++) {
//    if (setIdx < currentSet.member.size() &&  S[i] == currentSet.member[setIdx]) {
//      setIdx++;
//    } else {
//      excludedElements.push_back(S[i]);
//      excludedElementsSum+= S[i];
//    }
//  }
//
//  return excludedElementsSum;
//}
//
//uint64_t inclusionExclusionGenerator(const int K,  const uint64_t largest,
//                             const vector<uint64_t> &S, const uint64_t SSum,
//                             uint64_t CBest, uint64_t maxSoFar) {
//
//  uint64_t CMin = SSum - (K-1) * (CBest-1);
//  uint64_t lowerBound = (CMin > largest) ? CMin - largest : 0;
//
//  ss::IECompletionGenerator generator(
//          lowerBound, CBest-largest-1, &S[1], S.size() - 1, SSum-largest, false);
//
//  //ss::SSCompletionGenerator generator(&S[1],S.size()-1,lowerBound, CBest-largest-1);
//
//  SetNode currentSet;
//
//
//  while (CMin < CBest &&
//         maxSoFar < CBest &&
//         generator.next(currentSet) ) {
//
//
//	  vector<uint64_t> excludedElements;
//	  uint64_t excludedElementsSum = setExcludedElements(excludedElements,S,currentSet);
//
//	  uint64_t currentSum = currentSet.getSum() + largest;
//	  uint64_t newValue = std::max(currentSum,
//                                 search(K-1,excludedElements,excludedElementsSum,
//                                        CBest, std::max(currentSum,maxSoFar)));
//
//	  CBest = std::min(CBest, newValue);
//
//  }
//
//
//  return CBest;
//}
