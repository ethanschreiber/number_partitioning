/*
 * HorowitzSahni.cpp
 *
 *  Created on: May 8, 2014
 *      Author: ethan
 */

#include "HorowitzSahni.hpp"
#include "SubsetSum.hpp"
#include "KK.hpp"
#include "../utils/MemoryUsage.hpp"

namespace ss {

uint64_t executeHS2(const uint64_t S[], const int N, const uint64_t sum) {

  // TODO: include largest element and search for perfect - largest
  // Will require some doing
  uint64_t perfect = (sum+1) / 2;

  uint64_t kkBound = kk(S, N, 2, sum);

  uint64_t upper = getPartitionUpper(kkBound, perfect, sum); 	// Get upper bound
  if (upper < perfect) {  // If cgaBound was perfect, we are done
    return perfect;
  }
  uint64_t lower = sum-upper;	                     // Lower is complement of upper

  vector<SetNodeBitset> a;                         // all subset sums from first half of numbers
  vector<SetNodeBitset> b;                         // all subset sums from second half of numbers

  generateAllSets(S, N, a, 0    , N/2-1  ,true);   // combinations of 1st half of numbers (sorted ascending)
  generateAllSets(S, N, b, N/2  , N-1    ,false);  // combinations of 2nd quarter of numbers (sorted descending)

  size_t bAnchor = 0;                              // bPtr starts searching from here


  for (size_t aPtr=0; aPtr < a.size(); aPtr++) {
    const uint64_t &aValue = a[aPtr].sum();        // For readability, the value in the a vector

    while (bAnchor < b.size() &&                   // Move bAnchor to highest value that might fit
           aValue + b[bAnchor].sum() > upper) {    // Keep looking at smaller number in b until we
      bAnchor++;                                   // are under upper bound. (remember b is descending)
    }

  }

  return upper+1;                                 // return the number of subset sums stored in ALLSUMS
}

}
