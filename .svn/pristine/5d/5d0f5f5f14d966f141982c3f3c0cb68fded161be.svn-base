/*
 * Schroeppel_Shamir.cpp
 *
 *  Created on: Oct 2, 2012
 *      Author: ethan
 */

#include "Schroeppel_Shamir.hpp"
#include  <iostream>
using std::cout;
using std::endl;

namespace ss {


// ============================================================================
// Schroeppel and Shamir Helper Functions
// ============================================================================

void initializeSets(const uint64_t S[MAXN], const int n,
                           vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d) {


  generateAllSets(S, a, 0    , n/4-1  ); // combinations of 1st quarter of numbers
  generateAllSets(S, b, n/4  , n/2-1  ); // combinations of 2nd quarter of numbers
  generateAllSets(S, c, n/2  , n*3/4-1); // combinations of 3rd quarter of numbers
  generateAllSets(S, d, n*3/4, n-1    ); // combinations of 4th quarter of numbers

}
void initializeHeaps(const uint64_t S[MAXN], const int n,
                       vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d,
                       SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {

  // --------------------------------------------------------------------------
  //construct min heap of initial combinations of sets from array A and array B
  // --------------------------------------------------------------------------

  for (size_t aIndex = 0; aIndex < a.size() && a[aIndex].sum() <= upper; aIndex++) {  // for each set in A array
    abheap.push_back(SSHeapNode(aIndex,  // aptr pointer is same as index
                          0,           // smallest value of bsums is first element
                          a[aIndex])); // b.front().sum == 0 --> [a[index].sum + b.front().sum] == a[index].sum,
  }

  abheap.make_heap();


  // --------------------------------------------------------------------------
  //construct max heap of initial combinations of sets from array C and array D
  // --------------------------------------------------------------------------

  int dIndex = d.size() - 1;                  // index to largest value in dsums

  for (size_t cIndex = 0; cIndex < c.size(); cIndex++) {  // process csums in increasing order
    if (c[cIndex].sum() > upper) {
      break;                                    // no more entries to add to heap
    }

    while (c[cIndex].sum() + d[dIndex].sum() > upper) {
      dIndex--;
    }

    cdheap.
      push_back(SSHeapNode(cIndex,                    // cpointer is index
                     dIndex,                          // largest value of dsums <= target
                     c[cIndex].sum() + d[dIndex].sum())); // sum of heap element
  }

  cdheap.make_heap();
}

void initialize(const uint64_t S[MAXN], const int n,
                       vector<SSSetNode> &a,vector<SSSetNode> &b,vector<SSSetNode> &c,vector<SSSetNode> &d,
                       SSMinHeap &abheap, SSMaxHeap &cdheap, const uint64_t upper) {


  initializeSets(S,n,a,b,c,d);
  initializeHeaps(S,n,a,b,c,d,abheap,cdheap,upper);
}

// This uses Schroeppel and Shamir!
//     ALLSETS takes an array NUM of integers sorted in increasing order,
//     the length N of the vector, the SUM of all the numbers, a LOWER
//     bound and an UPPER bound on the subset sums, and an array ALLSUMS.
//     It computes all possible subset sums of the given numbers, and
//     loads them into the array ALLSUMS, in the order they are generated.
//     It returns the number of subset sums.

size_t generateSumsSS(const uint64_t S[MAXN], const int n, const uint64_t lower, const uint64_t upper,
             vector<uint64_t> &allsums)

{
  vector<uint64_t> a;          // all subset sums from first quarter of numbers
  vector<uint64_t> b;          // all subset sums from second quarter of numbers
  vector<uint64_t> c;          // all subset sums from third quarter of numbers
  vector<uint64_t> d;          // all subset sums from fourth quarter of numbers

  SSMinHeap abheap;    // Min Heap Comparator
  SSMaxHeap cdheap;   // Max Heap Comparator

  deque<uint64_t> cdlist;      // list of subset sums removed from CD heap

  SSHeapNode newHeapNode;       // new element being added to heap

  uint64_t subsum;             // subset sum of first subset


  generateAllSums (S, a, 0    , 0ll, n/4-1);   // combinations of 1st quarter of numbers
  std::sort( a.begin(), a.end() ,std::less<uint64_t>());  // Sort in ascending order

  generateAllSums (S, b, n/4  , 0ll, n/2-1); // combinations of 2nd quarter of numbers
  std::sort( b.begin(), b.end() ,std::less<uint64_t>());  // Sort in ascending order

  generateAllSums (S, c, n/2  , 0ll, n*3/4-1); // combinations of 3rd quarter of numbers
  std::sort( c.begin(), c.end() ,std::less<uint64_t>());  // Sort in ascending order

  generateAllSums (S, d, n*3/4, 0ll, n-1); // combinations of 4th quarter of numbers
  std::sort( d.begin(), d.end() ,std::less<uint64_t>());  // Sort in ascending order

  // --------------------------------------------------------------------------
  //construct min heap of initial combinations of sets from array A and array B
  // --------------------------------------------------------------------------

  for (size_t index = 0; index < a.size() && a[index] <= upper; index++) {  // for each set in A array
    abheap.push_back(SSHeapNode(index,          // aptr pointer is same as index
                          0,                    // smallest value of bsums is first element
                          a[index]));           // a[index].sum + b.front().sum, b.front().sum = 0
    }
    abheap.make_heap();   // make the heap


    // --------------------------------------------------------------------------
    //construct max heap of initial combinations of sets from array C and array D
    // --------------------------------------------------------------------------

    int dIndex = d.size() - 1;                      // index to largest value in dsums

    for (size_t cIndex = 0; cIndex < c.size(); cIndex++) {  // process csums in increasing order
      if (c[cIndex] > upper) {
        break;                                    // no more entries to add to heap
      }

      while (c[cIndex] + d[dIndex] > upper) {
        dIndex--;
      }

      cdheap.
        push_back(SSHeapNode(cIndex,                     // cpointer is index
                       dIndex,                  // largest value of dsums <= target
                       c[cIndex] + d[dIndex]));  // sum of heap element
    }
    cdheap.make_heap();

  // --------------------------------------------------------------------------
  // Now fill in the allsums vector
  // --------------------------------------------------------------------------

  while (!abheap.empty()) {                      // until AB heap is empty

    // first remove sets with sums above upper bound from list
    while (!cdlist.empty() && abheap.front().sum + cdlist.front() > upper) {
      cdlist.pop_front();
    }
    // add new sets to list with sums within bounds
    uint64_t topsum = cdheap.front().sum + abheap.front().sum;     //sum of elements on top of heaps
    while (!cdheap.empty() && topsum >= lower) {  // new set within bounds
      if (topsum <= upper) {                      // new set within bounds
        cdlist.push_back(cdheap.front().sum);     // add heap element to list
      }

      if (cdheap.front().y > 0) {                        // there is another element in this column
        SSHeapNode newElement(cdheap.front().x,            // keep same row
                            cdheap.front().y - 1,        // replace with next combination in column
                            c,d);                        // sum is c[x] + d[y]

        cdheap.pop();                                              // Remove old head

        cdheap.push(newElement);                                   // add new element to heap vector

      } else {                                                          // no more elements in this column
        cdheap.pop();                                              // Remove old head
      }

      topsum = cdheap.front().sum + abheap.front().sum;      // sum of two top elements of heaps
    }


    for (size_t index=0;index<cdlist.size();index++) {
      subsum = cdlist[index] + abheap.front().sum;  // first subset sum
      if (subsum >= lower && subsum <= upper) {     // subset sum within bounds
        allsums.push_back(subsum);                  // store subset sum in result vector
      }
    }

    if (abheap.front().y < b.size() - 1) {            // there is another element in this column
      newHeapNode.x = abheap.front().x;               // replace with next combination in this column
      newHeapNode.y = abheap.front().y + 1;
      newHeapNode.sum = a[newHeapNode.x] + b[newHeapNode.y];  // sum of new subset

      abheap.pop();
      abheap.push(newHeapNode);
    } else {
      abheap.pop();
    }
  }
  return allsums.size();                                 // return the number of subset sums stored in ALLSUMS
}

size_t generateSetsSS(const uint64_t S[MAXN], const int n,
                      const uint64_t lower, const uint64_t upper,
                      vector<SetNode> &allSets) {
  vector<SSSetNode> allSetsBitSet;

  generateSetsSS(S,n,lower,upper,allSetsBitSet);
  allSets.resize(allSetsBitSet.size());

  for (size_t i=0;i<allSetsBitSet.size();i++) {

    for (int j=0;j<n;j++) {
        if (allSetsBitSet[i].set()[j]) {
          allSets[i].push_back(S[j]);
        }
    }
  }

  return allSets.size();
}
} // end namespace
