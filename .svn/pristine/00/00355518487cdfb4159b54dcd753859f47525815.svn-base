/*
 * MoffittSS.cpp
 *
 *  Created on: Sep 19, 2013
 *      Author: ethan
 */

#include "MoffittSS.hpp"

#include  <iostream>
using std::cout;
using std::endl;

namespace moffitt {


uint64_t schroeppelShamir(const int K,
                          uint64_t CMin, uint64_t CBest, uint64_t maxSoFar,
                          const vector<uint64_t> &S, const uint64_t SSum)
{
  vector<ss::SSSetNode> a;          // all subset sums from first quarter of numbers
  vector<ss::SSSetNode> b;          // all subset sums from second quarter of numbers
  vector<ss::SSSetNode> c;          // all subset sums from third quarter of numbers
  vector<ss::SSSetNode> d;          // all subset sums from fourth quarter of numbers

  ss::SSMinHeap abheap;   // Min Heap Comparator
  ss::SSMaxHeap cdheap;   // Max Heap Comparator

  deque<ss::SSHeapNode> cdlist;    // list of subset sums removed from CD heap

  uint64_t largest = S[0];
  uint64_t upper = CBest - largest - 1;
  uint64_t lower = CMin - largest;

  // Initialize the 4 vectors and 2 heaps
  ss::initialize(&S[1],S.size()-1,a,b,c,d,abheap,cdheap,upper);
  // --------------------------------------------------------------------------
  // Now fill in the allsums vector
  // --------------------------------------------------------------------------

  while (CBest > maxSoFar &&      // While the best found under this
         !abheap.empty()) {       // until AB heap is empty



    // remove sets with sums above upper bound from cdlist
    while (!cdlist.empty() && abheap.front().sum + cdlist.front().sum > upper) {
      cdlist.pop_front();
    }

    // TODO: Could recurse first with everything already in cdlist
    // before adding new elements to it. This could speed things up

    // add new sets with sums within bounds to cdlist
    uint64_t topsum = cdheap.front().sum +
                      abheap.front().sum;        //sum of elements on top of heaps
    while (!cdheap.empty() && topsum >= lower) { // new set within bounds

      if (topsum <= upper) {                    // new set within bounds
        cdlist.push_back(cdheap.front());       // add heap element to list
      }

      if (cdheap.front().y > 0) {               // there is another element in this column
    	  ss::SSHeapNode
    	    newElement(cdheap.front().x,          // keep same row
    	               cdheap.front().y - 1,      // replace with next combination in column
                     c,d);                      // sum is c[x] + d[y-1]

        cdheap.pop();                           // Remove old head
        cdheap.push(newElement);                // add new element to heap vector

      } else {                                  // no more elements in this column
        cdheap.pop();                           // Remove old head
      }

      topsum = cdheap.front().sum +
               abheap.front().sum;              // sum of two top elements of heaps
    }


    // Combine each element from cdlist with the top element from
    // abheap, these are all within range
    for (size_t index=0;index<cdlist.size();index++) {
      uint64_t subsum = cdlist[index].sum + abheap.front().sum;  // first subset sum
      ss::SSSetNode node(subsum, c[cdlist[index].x].set() |
                                 d[cdlist[index].y].set() |
                                 a[abheap.front().x].set() |
                                 b[abheap.front().y].set());

      vector<uint64_t> excluded;
      uint64_t excludedSum = setExcludedElements(excluded, &S[1], S.size()-1, node);
      uint64_t includedSum = largest + node.sum();

//      cout << spaces(K) << "-------- Schroeppel Shamir ---------" << endl
//           << spaces(K) << "K      : " << K << endl
//           << spaces(K) << "MSF    : " << maxSoFar << endl
//           << spaces(K) << "CBest  : " << CBest << endl
//           << spaces(K) << "New Sum: " << includedSum << endl
//           << spaces(K) << "------------------------------------" << endl << endl;



      uint64_t newValue = std::max(includedSum,
                                   search(K-1, excluded, excludedSum,
                                          CBest, std::max(maxSoFar,includedSum)));  // If includedSum > maxSoFar, update maxSoFar

      if (newValue < CBest) {             // If there is a new best

//        cout << endl
//             << spaces(K) << "============== New CBest ==============" << endl
//             << spaces(K) << "K        : " << K << endl
//             << spaces(K) << "Old CBest: " << CBest << endl;


        CBest = newValue;                 // Set CBest
        CMin = SSum - (K-1) * (CBest-1);  // Set CMin according to new CBest
        upper = CBest - largest - 1;      // Upper bound for SS subtracts the largest element and needs to be 1 better
        lower = CMin - largest;           // Lower bound for SS subtracts the largest element.

//        cout << spaces(K) << "New CBest: " << CBest << endl
//             << spaces(K) << "CMin     : " << CMin << endl
//             << spaces(K) << "============== New CBest ==============" << endl << endl;


        if (CBest <= maxSoFar) {  // If the new CBest is good enough
          return maxSoFar;        // Return now
        }

        // remove sets with sums above upper bound from cdlist
        while (!cdlist.empty() && abheap.front().sum + cdlist.front().sum > upper) {
          cdlist.pop_front();
        }

      }


    }

    // If there is another element from the b set, add it.
    // Then, remove top element from abheap.
    if (abheap.front().y < b.size() - 1) {     // there is another element in this column
    	ss::SSHeapNode newNode(abheap.front().x, // new element being added to heap
                       abheap.front().y + 1,   // replace with next combination in this column
                       a,b);

      abheap.pop();                            // Pop old value
      abheap.push(newNode);                    // add new element to heap vector
    } else {
      abheap.pop();
    }

  }

  return CBest;
}

} // End Namespace

