/*
 * Schroeppel_Shamir.cpp
 *
 *  Created on: Oct 2, 2012
 *      Author: ethan
 */

#include "Schroeppel_Shamir_Half.hpp"
#include  <iostream>
using std::cout;
using std::endl;

namespace ss {


// ============================================================================
// Schroeppel and Shamir Helper Functions
// ============================================================================

// This uses Schroeppel and Shamir!
//     ALLSETS takes an array NUM of integers sorted in increasing order,
//     the length N of the vector, the SUM of all the numbers, a LOWER
//     bound and an UPPER bound on the subset sums, and an array ALLSUMS.
//     It computes all possible subset sums of the given numbers, and
//     loads them into the array ALLSUMS, in the order they are generated.
//     It returns the number of subset sums.


size_t generateSumsSSHalf(const uint64_t S[MAXN], const int n, const uint64_t lower, const uint64_t upper,
             vector<uint64_t> &allsums)

{
  vector<uint64_t> a;         // all subset sums from first half of numbers
  vector<uint64_t> b;         // all subset sums from second half of numbers

  SSMinHeap abheap;           // Min Heap Comparator

  generateAllSums (S, a, 0, 0ll, n/2-1);   // combinations of 1st half of numbers
  std::sort( a.begin(), a.end() ,std::less<uint64_t>());  // Sort in ascending order

  generateAllSums (S, b, n/2, 0ll, n-1); // combinations of 2nd half of numbers
  std::sort( b.begin(), b.end() ,std::less<uint64_t>());  // Sort in ascending order


  // --------------------------------------------------------------------------
  //construct min heap of initial combinations of sets from array A and array B
  // --------------------------------------------------------------------------

  for (size_t index = 0; index < a.size() && a[index] <= upper; index++) {  // for each set in A array
    abheap.push_back(SSHeapNode(index,          // aptr pointer is same as index
                          0,                    // smallest value of bsums is first element
                          a[index]));           // a[index].sum + b.front().sum, b.front().sum = 0
  }
  abheap.make_heap();   // make the heap


  // --------------------------------------------------------------------------
  // Now fill in the allsums vector
  // --------------------------------------------------------------------------

  while (!abheap.empty() && abheap.front().sum <= upper) {   // until AB heap is empty or we exceed upper bound

    uint64_t sum = abheap.front().sum;                        //sum of elements on top of heap

    if (sum >= lower) {                                       // subset sum within bounds
      allsums.push_back(sum);                                 // store subset sum in result vector
    }
    popPushNext(abheap,a,b);    // Pop the a/b sum and add a/next(b) if next(b) exists
  }

  return allsums.size();                                 // return the number of subset sums stored in ALLSUMS
}


// ALLSETS takes an array NUM of integers sorted in increasing order,
//     the length N of the vector, the SUM of all the numbers, a LOWER
//     bound and an UPPER bound on the subset sums, and an array ALLSUMS.
//     It computes all possible subset sums of the given numbers, and
//     loads them into the array ALLSUMS, in the order they are generated.
//     It returns the number of subset sums.

size_t generateSetsSSHalf(const uint64_t S[MAXN], const int n,
                          const uint64_t lower, const uint64_t upper,
                          vector<SSSetNode> &allSets)

{
  vector<SSSetNode> a;          // all subset sums from first quarter of numbers
  vector<SSSetNode> b;          // all subset sums from second quarter of numbers

  SSMinHeap abheap;    // Min Heap Comparator

  generateAllSets(S, a, 0    , n/2-1  ); // combinations of 1st half of numbers
  generateAllSets(S, b, n/2  , n-1  );   // combinations of 2nd half of numbers

  // --------------------------------------------------------------------------
  //construct min heap of initial combinations of sets from array A and array B
  // --------------------------------------------------------------------------

  for (size_t aIndex = 0; aIndex < a.size() && a[aIndex].sum() <= upper; aIndex++) {  // for each set in A array
    abheap.push_back(SSHeapNode(aIndex,  // aptr pointer is same as index
                          0,           // smallest value of bsums is first element
                          a[aIndex])); // b.front().sum == 0 --> [a[index].sum + b.front().sum] == a[index].sum,
  }
  abheap.make_heap();

  // --------------------------------------------------------------------------
  // Now fill in the allsums vector
  // --------------------------------------------------------------------------

  while (!abheap.empty() && abheap.front().sum <= upper) {   // until AB heap is empty or we exceed upper bound

    uint64_t sum = abheap.front().sum;                       // sum of elements on top of heap

    if (sum >= lower) {
      allSets.push_back(SSSetNode(sum,a[abheap.front().x].set() |
                                   b[abheap.front().y].set() ));
    }

    // If there is another element from the b set, add it.
    // Then, remove top element from abheap.
    if (abheap.front().y < b.size() - 1) {          // there is another element in this column
      SSHeapNode newNode(abheap.front().x,            // new element being added to heap
                       abheap.front().y + 1,        // replace with next combination in this column
                       a,b);

      abheap.pop();                            // Pop old value
      abheap.push(newNode);                    // add new element to heap vector
    } else {
      abheap.pop();
    }
  }

  return allSets.size();                                 // return the number of subset sums stored in ALLSUMS
}

size_t generateSetsSSHalf(const uint64_t S[MAXN], const int n,
                          const uint64_t lower, const uint64_t upper,
                          vector<SetNode> &allSets) {
  vector<SSSetNode> allSetsBitSet;

  generateSetsSS(S,n,lower,upper,allSetsBitSet);
  allSets.resize(allSetsBitSet.size());

  for (size_t i=0;i<allSetsBitSet.size();i++) {

    for (int j=0;j<n;j++) {
        if (allSetsBitSet[i].set()[j]) {
          allSets[i].push_back(S[j]);
        }
    }
  }

  return allSets.size();
}
} // end namespace
