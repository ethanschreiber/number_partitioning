/*
 * DPMatrix.hpp
 *
 *  Created on: Oct 2, 2012
 *      Author: ethan
 */

#ifndef DPMATRIX_HPP_
#define DPMATRIX_HPP_

#include "../PackingUtils.hpp"
#include <bitset>



namespace ss {
typedef std::bitset<MAXN> Bitset;
const Bitset BITSET_ONE(1);

// A matrix used for the dynamic programming algorithm
class DPMatrix {
private :
  uint64_t m_S[MAXN];
  uint64_t *m_matrix;
  Bitset  *m_oneMatrix; // Characteristic functions of all slots that have one subset
  bool *m_inUse;
  int m_n;
  int m_minSubsetSum;
  int m_numSubsetSums;
  int m_targetSubsetSum;

protected :

  inline void print(Bitset bitset,int subsetsum) {

    int sum = 0;
    bool isFirst = true;
    for (int i=0;i<m_n;i++) {
      if (bitset[i]) {

        if (isFirst) {
          isFirst = false;
        } else {
          cout << " + ";
        }
        cout << m_S[i];
        sum += m_S[i];
      }
    }
    if (sum == subsetsum) {
      cout << " = " << subsetsum << endl;
    } else {
      cout << " != " << subsetsum << endl
           << "EXITING!" << endl;
      exit(0);
    }
  }
  inline int getIndex(int elementIdx, int subsetSum) const {
    return
        (elementIdx*m_numSubsetSums) +         // m_numSubsetSums per row
        (subsetSum-m_minSubsetSum);   // First subsetsum stored is m_minSubsetSum
  }

  inline void addBitset(vector<Bitset> &bitsets, const Bitset &bitset) {

    bitsets.push_back(bitset);
  }
  inline void setCount(int elementIdx,int subsetSum,uint64_t value) {
    m_matrix[getIndex(elementIdx,subsetSum)] = value;
  }

  inline uint64_t getCount(int elementIdx, int subsetSum) const{
    if (subsetSum < m_minSubsetSum) {     // Special case
      if (subsetSum == 0) {             // Can always get subset sum of 0
        return 1;
      } else {                          // Can never get subset between 1 and min subset sum
        return 0;
      }
    } else {                            // Have to look it up
      return m_matrix[getIndex(elementIdx,subsetSum)];
    }
  }
  void fillMatrix(const uint64_t S[MAXN], int minSubsetSum, const int targetSubsetSum);

  void generateSubsets(vector<Bitset> &bitsets,const Bitset &bitset,
                       const int SIdx,const int subsetSumLeft);


  bool searchBC(const int binIdx, const int &numBins, const int subsetSumLeft,
                bool isElementUsed[], int SIdx);

  bool searchIA(int SIdx, const int numBins, int subsetSumLeft[], Bitset bitsRequired,int targetCount);
public :
  // n - The number of items in the input set
  // minSubsetSum - The minimum subsetSum to store, i.e., the smallest input number
  // targetSubsetSum - The subset sum we are trying to find subsets that sum to
  DPMatrix(const uint64_t S[MAXN], int n,int minSubsetSum,int targetSubsetSum);

  // Destructor
  ~DPMatrix();


  void DPStats();

  int getNumSubsets() const;


  string toString(const uint64_t S[]) const;

  size_t generateSubsets(vector<Bitset> &bitsets);

  size_t generateSubsets(vector<Bitset> &bitsets, uint64_t lowerbound, uint64_t upperBound);

  bool searchBC(const int numBins);
  bool searchIA(const int numBins);

};

template <typename BitsetType>
string getBits(const BitsetType &bitset,int groupSize,int numBits) {
  std::ostringstream out;
  for (int i=numBits-1;i>=0;i--) {
    out << bitset[i];
    if (i % groupSize == 0 && i > 0) {
      out << " ";
    }
  }
  return out.str();
}
}

#endif /* DPMATRIX_HPP_ */
