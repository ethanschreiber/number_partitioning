/*
 * HorowitzSahni.cpp
 *
 *  Created on: May 8, 2014
 *      Author: ethan
 */

#include "HorowitzSahni.hpp"
#include "SubsetSum.hpp"
#include "KK.hpp"
#include "../utils/MemoryUsage.hpp"

namespace ss {

uint64_t executeHS2(const uint64_t S[], const int N, const uint64_t sum) {

  // TODO: include largest element and search for perfect - largest
  // Will require some doing
  uint64_t perfect = (sum+1) / 2;

  uint64_t kkBound = kk(S, N, 2, sum);

  uint64_t upper = getPartitionUpper(kkBound, perfect, sum); 	// Get upper bound
  if (upper < perfect) {  // If cgaBound was perfect, we are done
    return perfect;
  }
  uint64_t lower = sum-upper;	                     // Lower is complement of upper

  vector<uint64_t> a;                         // all subset sums from first half of numbers
  vector<uint64_t> b;                         // all subset sums from second half of numbers

  generateAllSums(S,  a, 0    , N/2-1  ,true);   // combinations of 1st half of numbers (sorted ascending)
  generateAllSums(S,  b, N/2  , N-1    ,false);  // combinations of 2nd quarter of numbers (sorted descending)

  auto aIt = a.begin();
  auto bIt = b.begin();             // Iterator to b list


  for (uint64_t aValue : a) {       // For each element of a
    uint64_t sum;                   // sum of a and b

    do {
      sum = aValue + *bIt;          // Sum of current a and b values
      bIt++;
    } while (bIt != b.end() &&      // While there are elements left in b
             sum > upper);          // And the current sum > upper bound

    if (sum <= upper) {

    }

  }
  for (size_t aPtr=0; aPtr < a.size(); aPtr++) {
    const uint64_t &aValue = a[aPtr];        // For readability, the value in the a vector

    while (bAnchor < b.size() &&                   // Move bAnchor to highest value that might fit
           aValue + b[bAnchor] > upper) {    // Keep looking at smaller number in b until we
      bAnchor++;                                   // are under upper bound. (remember b is descending)
    }

  }

  return upper+1;                                 // return the number of subset sums stored in ALLSUMS
}

}
