/* This program finds optimal solutions to arbitrary multi-way number
 partitioning problems using the complete greedy algorithm.  It sorts
 the numbers, and assigns each to one of the sets in turn, searching
 the resulting k-ary tree, using branch-and-bound.  The first solution
 found is the greedy solution.  This version checks to see if any of
 the current subsets are empty, and if so, only places the next
 element in one empty subset. This version uses all int64_t
 variables, except for indices.  This version uses as the optimization
 criteria the maximum subset sum instead of the difference between the
 largest and smallest subset sums.  This version is optimized to
 eliminate all but one permutation of the subsets. Rather than making
 a new copy of the array of subset sums for each recursive call, this
 version keeps a single global array, makes changes at each node, and
 undoes those changes for the next node. This version prevents
 assigning a number to multiple empty sets by passing as a parameter
 the first subset to assign a new number to.  This version computes
 the greedy solution when there are two numbers left, instead of
 waiting until there is only one number left. This version uses 48-bit
 integers. */

#include "../PackingUtils.hpp"
#include <stdio.h>            // standard I/O library
#include <stdint.h>
#include <cstring>            // for memset
#include <iostream>
#include <algorithm>
#include <iomanip>

using std::cout;
using std::endl;

#define MAXN_CGA 1000
#define INITSEED  13070       // initial random seed, in decimal
#define A 25214903917         // multiplier
#define C 11                  // additive constant
#define MASK 281474976710655  // 2^{48}-1

static int g_N;                        // actual number of values to be partitioned
static int g_K;                        // actual number of subsets being partitioned into
//static int64_t g_seed;               // current random number seed

static int64_t g_elements[MAXN_CGA]; // array of numbers to be partitioned
static int64_t g_sums[MAXN_CGA];     // sorted array of subset sums
static int64_t g_minMax;             // minimum maximum subset sum in a complete partition so far
static int64_t g_largest;            // largest individual value
static int64_t g_perfect;            // maximum subset sum in perfect partition
static int64_t g_lowerBound;         // maximum of perfect and largest
static int64_t g_nodeCount;          // total calls to search routine

static int64_t g_nodeCountLimit;  // The max nodes before returning
//// ============================================================================
//// INIT initializes the array with random numbers, and the vector with the
//// random number in the first position, and all zeros in the others. It returns
//// the sum of all the numbers.
//// ============================================================================
//int64_t init (int64_t elements[MAXN]) {   // array of numbers to be initialized
//
//  int i, j;                               // utility indices
//  int64_t sum;                            // sum of all the numbers
//
//  sum = 0;
//  for (i = 0; i < g_N; i++)                 // for each element of array
//     {g_seed = (A * g_seed + C) & MASK;       // next seed in random sequence
//     elements[i] = g_seed;                  // random value from zero to 2^{48}-1
//     sum += elements[i];}                 // compute sum of all numbers
//  return sum;
//}

// ============================================================================
// First is the first bin to consider to avoid putting two in empty bins
// SEARCH takes a Vector of K subset sums, and the NEXT index in the array A,
// and adds a[next] to each subset in the vector, as long as the resulting sum
// is strictly less than the minimum of the maximum subset sums so far.  For
// each new partial partition, it recursively searches all possible completions
// of the partial partition that could be better than the best so far.  It will
// only place the new element is one empty subset sum, to avoid generating
// permutations of the same partition. If it finds a perfect partition, or one
// where the largest subset sum equals the largest number, it returns one,
// otherwise it returns zero
// ============================================================================
bool search (int next, int first, int discrepencies) {

  if (g_nodeCount > g_nodeCountLimit) {
    return false;
  }

  int64_t max;       // largest subset sum in complete partition
  int64_t newSS;     // largest subset sum of last two subsets
  int64_t y, z;      // subset sums of last two subsets



  g_nodeCount++;     // count node generations

  bool result = false;
  // ---------------------
  // only two numbers left
  // ---------------------
  if (next == g_N - 2) {
    z = g_sums[0] + g_elements[next];     // add next to last number to smallest subset sum
    if (z <= g_sums[1]) {
      newSS = z + g_elements[next+1];     // add last number to same subset
    } else {
      y = g_sums[1] + g_elements[next+1]; // add last number to second smallest subset
      newSS = (z >= y) ? z : y;
    }

    if (newSS >= g_sums[g_K-1]) {
      max = newSS;                        // new largest subset sum
    } else {
      max = g_sums[g_K-1];                  // previous largest subset sum is still largest
    }

    if (max < g_minMax) {                 // found better solution than best so far
      //cout << std::setw(7) << g_nodeCount << "   " << g_minMax << endl;
      g_minMax = max;                     // keep track of best so far
      if (g_minMax == g_lowerBound) {
        result = true;               // optimal solution found, quit
      }
    }
  } else {
    // --------------------------------------------
    // consider placing next number in every subset
    // --------------------------------------------
    for (int i = first; i < g_K; i++) {
      int newDiscrepencies = discrepencies - (i-first);
      if (newDiscrepencies < 0) {
        break;
      }
      newSS = g_elements[next] + g_sums[i]; // add next number to current subset
      if (newSS < g_minMax) {               // new subset sum is smaller than smallest max
        int j;
        for (j = i; j < g_K - 1; j++) {     // find place for new subset in sorted order
          if (newSS > g_sums[j+1]) {
            g_sums[j] = g_sums[j+1];        // copy smaller elements back
          } else {
            break;                          // found correct place, break out
          }
        }
        g_sums[j] = newSS;                  // add new subset sum in correct position

        if (first > 0 && i == first) {            // This is so we don't put the same item
          result = search (next + 1, first - 1, newDiscrepencies);  // in two empty bins
        } else {
          result = search (next + 1, first, newDiscrepencies);
        }

        if (result) {                       // If we found optimal solution, break out of loop
          break;                            // signal that optimal solution was found
        }

        newSS = g_sums[j] - g_elements[next];  // original element of array
        for (; j > i; j--) {                   // insert back into sorted order
          g_sums[j] = g_sums[j-1];             // move larger elements forward
        }
        g_sums[i] = newSS;                     // restore original element in array
        if (g_sums[g_K-1] >= g_minMax) {
          result = false;
          break;
        }
      } else {   // new element >= minmax, no point in adding to larger subsets
        break;   // so prune
      }
    }
  }

  return result;                                 // return, without finding optimal solution
}

// Assume that problem.S is sorted in descending order
int64_t executeCGA(const PartitioningProblem &problem, int nodeCountLimit,int maxDiscrepencies) {

  const int &K = problem.K;
  const int64_t &sum = problem.sum;    // sum of all the numbers

  g_nodeCountLimit = nodeCountLimit;
  g_K = K;
  g_N = problem.N;


  memcpy(g_elements,problem.S,sizeof(int64_t) * g_N);  // Copy over elements

  std::sort( g_elements, g_elements+problem.N ,std::greater<int64_t>());  // Sort in descending order

  g_largest = g_elements[0];                      // store largest individual value
  g_perfect = (sum % g_K == 0) ? (sum / g_K) : ((sum / g_K) + 1);
  g_lowerBound = std::max(std::max(g_largest,g_perfect),     // largest of 3 values
                          g_elements[g_K-1] + g_elements[g_K]);

  g_nodeCount = 0;                                // initialize node counter
  g_minMax = sum;                                 // largest possible subset sum

  memset(g_sums,0,sizeof(int64_t) * (g_K-1));     // initialize all but last vector element to zero
  g_sums[g_K-1] = g_elements[0];                  // put first number only in last subset

  search (1, g_K-2,maxDiscrepencies);                              // find optimal multi-way partition
  return g_minMax;
}

