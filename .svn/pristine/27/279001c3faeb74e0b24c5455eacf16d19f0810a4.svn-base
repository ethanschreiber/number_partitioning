/*
 * MoffittCached.cpp
 *
 *  Created on: Jul 31, 2013
 *      Author: ethan
 */


#include "MoffittCached.hpp"
#include "MoffittSS.hpp"
#include "../ss/CGA.hpp"


#include <iomanip>
#include <algorithm> // for copy
#include <iterator> // for ostream_iterator
#include <sstream>

namespace moffitt {

// ========
// CachedIE
// ========
MoffittCachedIE::MoffittCachedIE(const vector<uint64_t> &S, uint64_t min, uint64_t max) :
    m_root(NULL), m_S(S.begin(),S.end()){

  vector<ss::SSSetNode> sets;
  ss::generateSetsSS(&S[0], S.size(), min, max, sets);
  insert(sets);
}

MoffittCachedIE::~MoffittCachedIE() {
  delete m_root;
}

void MoffittCachedIE::clear(CachedIENode *node) {
  if (node->included != NULL) {
    clear(node->included);
  }

  if (node->excluded != NULL) {
    clear(node->excluded);
  }

  delete node;

}
void MoffittCachedIE::clear() {
  if (m_root != NULL) {
    clear(m_root);
    m_root = NULL;
  }
}
void MoffittCachedIE::insert(vector<ss::SSSetNode>& v) {

  // Insert first set
  const ss::DynamicBitset &set = v[0].set(); // Reference to bit set
  size_t idx = set.find_first();             // first index in first set
  CachedIENode ** ptr = &m_root;             // pointer to root pointer

  while (idx != ss::DynamicBitset::npos){    // While there are elements left
     *ptr = new CachedIENode(idx);           // Insert node for element
     ptr = &((*ptr)->included);              // Point to inclusion
     idx = set.find_next(idx);               // Find next index
  }

  // Insert remaining sets
  cout << "TMP DEBUG FOR LOOP" << endl;
  for (size_t i=1;i<v.size();i++) {
    push_back(v[i]);
  }
}

void MoffittCachedIE::push_back(const ss::SSSetNode &node) {
  const ss::DynamicBitset &set = node.set();    // Reference to bit set
  size_t idx = set.find_first();
  CachedIENode ** ptr = &m_root;                // pointer to root pointer

  while (idx != ss::DynamicBitset::npos){       // While there are elements left

    if (*ptr == NULL) {                         // If there is no node
      *ptr = new CachedIENode(idx);             // Insert node for element
      ptr = &((*ptr)->included);                // Point to inclusion
      idx = set.find_next(idx);                 // Find next index
    } else if (idx < (*ptr)->ieIdx) {           // If less than idx
      *ptr = new CachedIENode(idx, NULL, *ptr); // Insert new node with exclusion pointing to old one
      ptr = &((*ptr)->included);
      idx = set.find_next(idx);                 // Find next index
    } else if (idx == (*ptr)->ieIdx) {          // If there is a match
      ptr = &((*ptr)->included);                // Point to incluion
      idx = set.find_next(idx);                 // Find next index
    } else {                                    // if idx > ptr->ieIdx, we exclude
      ptr = &((*ptr)->excluded);                // Point to exclusion
    }
  }
}

void MoffittCachedIE::searchAll() {
  ss::Bitset bitset;
  int count = searchAll(m_root, bitset,0);
  cout << "Count   : " << count << endl;

}

int MoffittCachedIE::searchAll(CachedIENode* node, ss::Bitset &bitset, uint64_t sum) {
  if (node!= NULL) {
    // Include
    bitset.set(node->ieIdx,true);
    int count = searchAll(node->included, bitset,sum+m_S[node->ieIdx]);
    bitset.set(node->ieIdx,false);

    // Exclude
    if (node->excluded != NULL) { // || sum >= tmpMin
      count += searchAll(node->excluded, bitset,sum);
    }
    return count;
  } else {
    return 1;
  }
}

uint64_t MoffittCachedIE::search(CachedIENode *node, const int K, ss::Bitset &elements,
                                 const uint64_t elementsSum, uint64_t CBest,
                                 uint64_t maxSoFar) {

  if (node != NULL) {
    uint8_t &idx = node->ieIdx;
    if (elements[idx]) {
      elements.set(idx,false);
      //search(node->included, K, elements, )
      elements.set(idx,true);
    }
  }

}

uint64_t MoffittCachedIE::search(const int K, ss::Bitset elements,
                                 const uint64_t elementsSum, uint64_t CBest,
                                 uint64_t maxSoFar) {
  return search(m_root, K, elements, elementsSum, CBest, maxSoFar);

}

// =============
// MoffittCached
// =============
MoffittCached::MoffittCached(const vector<uint64_t>& S, uint64_t min, uint64_t max, int K) : m_cachedIE(S,min,max) {

}

uint64_t MoffittCached::searchCached(const int K, ss::Bitset &elements,
                                     const uint64_t elementsSum,
                                     const uint64_t CBest, uint64_t maxSoFar) {

  uint64_t currentValue;
  if (K==1) {                          // If we have reached the last bin
    currentValue = elementsSum;        // All elements must go in it
  } else if (!elements.any()) {        // If there are no elements left
    currentValue = 0;                  // Then all remaining bins are empty
  } else {

    uint64_t CMin = elementsSum - (K-1) * (CBest-1);

    if (CMin < CBest) {
      //m_cachedIE.search();
      std::cerr<< "IMPLEMENT ME" << endl;

    } else {
      currentValue = CBest;
    }
  }

  return currentValue;
}

// ================
// Execute Function
// ================
uint64_t executeMoffittCached(const PartitioningProblem &problem, BinPackingStats &stats) {

  // Original maxSoFar is the minimum possible sum of a bin
  // We can assume all subsequent bins will be least this large
  uint64_t maxSoFar = divCeiling(problem.sum, (uint64_t) problem.K);  // Best we can do is divide evenly

  // Find upper bound
  const int NUM_NODES = 1000000;
  const int MAX_DISCREPENCIES = 5;
  uint64_t CBest = executeCGA(problem, NUM_NODES,MAX_DISCREPENCIES);

  uint64_t CMin = problem.sum - (problem.K-1) * (CBest-1);

  MoffittCached mc(vector<uint64_t>(problem.S,problem.S+problem.N),CMin, CBest-1, problem.K);
  ss::Bitset elements;
  uint64_t answer = mc.searchCached(problem.K,elements, problem.sum, CBest,maxSoFar);

  return answer;
}


} // End Namespace

